## Desaf铆o1de3:Corregir las actualizaciones de estado incorrectas

Este formulario tiene algunos errores. Haz clic en el bot贸n que aumenta la puntuaci贸n unas cuantas veces. Observa que no aumenta. A continuaci贸n, edita el nombre, y observa que la puntuaci贸n se ha 芦puesto al d铆a禄 con sus cambios. Por 煤ltimo, edita el apellido y observa que la puntuaci贸n ha desaparecido por completo.

Tu tarea es arreglar todos estos errores. A medida que los vayas arreglando, explica por qu茅 ocurre cada uno de ellos.

**App.jsx**
```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    player.score++;
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      lastName: e.target.value
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>
        {' '}
        <button onClick={handlePlusClick}>
          +1
        </button>
      </label>
      <label>
        Nombre:
        <input
          value={player.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Apellido:
        <input
          value={player.lastName}
          onChange={handleLastNameChange}
        />
      </label>
    </>
  );
}
```

### Respuesta

El problema con `handlePlusClick` era que mutaba el objeto `player`. Como resultado, React no sab铆a que hab铆a una raz贸n para volver a renderizar, y no actualizaba la puntuaci贸n en la pantalla. Por eso, cuando editabas el primer nombre, el estado se actualizaba, provocando un re-renderizado que _tambi茅n_ actualizaba la puntuaci贸n en la pantalla.

El problema con `handleLastNameChange` era que no copiaba los campos existentes de `...player` en el nuevo objeto. Por eso la puntuaci贸n se perd铆a despu茅s de editar el 煤ltimo nombre.


```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    setPlayer({
      ...player, // 
      score: player.score + 1,
    });
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player, // 
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      ...player, // 
      lastName: e.target.value
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>
        {' '}
        <button onClick={handlePlusClick}>
          +1
        </button>
      </label>
      <label>
        Nombre:
        <input
          value={player.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Apellido:
        <input
          value={player.lastName}
          onChange={handleLastNameChange}
        />
      </label>
    </>
  );
}
```

## Desaf铆o2de3:Encontrar y arreglar la mutaci贸n

Hay una caja que se puede arrastrar sobre un fondo est谩tico. Puedes cambiar el color de la caja usando la entrada de selecci贸n.

Pero hay un error. Si mueves la caja primero, y luego cambias su color, el fondo (隆que se supone que no se mueve!) 芦saltar谩禄 a la posici贸n de la caja. Pero esto no deber铆a ocurrir: la prop `position` del `Background` se establece en `initialPosition`, que es `{ x: 0, y: 0 }`. 驴Por qu茅 se mueve el fondo despu茅s del cambio de color?

Encuentra el error y arr茅glalo.

**App.jsx**
```jsx
import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    <>
      <select
        value={shape.color}
        onChange={handleColorChange}
      >
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background
        position={initialPosition}
      />
      <Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      >
        隆Arr谩strame!
      </Box>
    </>
  );
}
```

**Box.js**
```jsx
import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >{children}</div>
  );
}
```

**Background**
```jsx
export default function Background({
  position
}) {
  return (
    <div style={{
      position: 'absolute',
      transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
      width: 250,
      height: 250,
      backgroundColor: 'rgba(200, 200, 0, 0.2)',
    }} />
  );
};
```

### Respuesta

El problema estaba en la mutaci贸n dentro de `handleMove`. Mutaba `shape.position`, pero ese es el mismo objeto al que apunta `initialPosition`. Por eso tanto la forma como el fondo se mueven. (Es una mutaci贸n, por lo que el cambio no se refleja en la pantalla hasta que una actualizaci贸n no relacionada -el cambio de color- desencadena una nueva renderizaci贸n).

La soluci贸n es eliminar la mutaci贸n de `handleMove`, y utilizar la sintaxis extendida para copiar la forma. Ten en cuenta que `+=` es una mutaci贸n, as铆 que tienes que reescribirlo para usar una operaci贸n regular `+`.


```jsx
import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    setShape({ // 
      ...shape,
      position: {
        x: shape.position.x +dx,
        y: shape.position.y +dy,
      }
    })
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    <>
      <select
        value={shape.color}
        onChange={handleColorChange}
      >
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background
        position={initialPosition} //  La mutaci贸n hac铆a que esto cambiase
      />
      <Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      >
        隆Arr谩strame!
      </Box>
    </>
  );
}
```

## Desaf铆o3de3:Actualizar un objeto con Immer

Este es el mismo ejemplo con errores que en el desaf铆o anterior. Esta vez, arregla la mutaci贸n usando Immer. Para tu comodidad, `useImmer` ya est谩 importado, as铆 que tienes que cambiar la variable de estado `shape` para utilizarlo.

**package.json**
```jsx
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

**App.js**
```jsx
import { useState } from 'react';
import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    <>
      <select
        value={shape.color}
        onChange={handleColorChange}
      >
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background
        position={initialPosition}
      />
      <Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      >
        隆Arr谩strame!
      </Box>
    </>
  );
}
```

**Box.jsx**
```jsx
import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    >{children}</div>
  );
}
```

**Background.jsx**
```jsx
export default function Background({
  position
}) {
  return (
    <div style={{
      position: 'absolute',
      transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
      width: 250,
      height: 250,
      backgroundColor: 'rgba(200, 200, 0, 0.2)',
    }} />
  );
};
```

### Respuesta

**App.jsx**
```jsx
import { useState } from "react";
import { useImmer } from "use-immer";
import Background from "./Background.js";
import Box from "./Box.js";

const initialPosition = {
  x: 0,
  y: 0,
};

export default function Canvas() {
  const [shape, updateShape] = useImmer({ // 
    color: "orange",
    position: initialPosition,
  });

  function handleMove(dx, dy) {
    updateShape((shape) => { // 
      (shape.position.x += dx), (shape.position.y += dy); // 
    });
  }

  function handleColorChange(e) {
    updateShape((shape) => { // 
      shape.color = e.target.value; // 
    });
  }

  return (
    <>
      <select value={shape.color} onChange={handleColorChange}>
        <option value="orange">orange</option>
        <option value="lightpink">lightpink</option>
        <option value="aliceblue">aliceblue</option>
      </select>
      <Background position={initialPosition} />
      <Box color={shape.color} position={shape.position} onMove={handleMove}>
        隆Arr谩strame!
      </Box>
    </>
  );
}
```