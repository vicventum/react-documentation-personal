## â­ DesafÃ­oÂ 1Â deÂ 2:Â Fijar un contador de peticiones

EstÃ¡s trabajando en una aplicaciÃ³n de comercializaciÃ³n de arte que permite al usuario enviar varios pedidos de un artÃ­culo de arte al mismo tiempo. Cada vez que el usuario pulsa el botÃ³n Â«BuyÂ», el contador de Â«PendingÂ» deberÃ­a aumentar en uno. DespuÃ©s de tres segundos, el contador de Â«PendingÂ» deberÃ­a disminuir y el de Â«CompletedÂ» deberÃ­a aumentar.

Sin embargo, el contador de Â«PendingÂ» no se comporta como estÃ¡ previsto. Al pulsar Â«ComprarÂ», disminuye a `-1` (Â¡lo que no deberÃ­a ser posible!). Y si pulsas rÃ¡pido dos veces, ambos contadores parecen comportarse de forma imprevisible.

Â¿Por quÃ© ocurre esto? Arregla ambos contadores.

```jsx
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>
        Pendiente: {pending}
      </h3>
      <h3>
        Completado: {completed}
      </h3>
      <button onClick={handleClick}>
        Comprar     
      </button>
    </>
  );
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}
```

![[5.1-actualizaciones-de-estado-en-cola-1.png]]

### Respuesta


> [!important]
> El problema aquÃ­ es que tanto `setPending` como `setCompleted` estÃ¡n usando el valor anterior del estado antes de hacer el renderizado, por lo que cuando la funciÃ³n `handleClick` se pone en espera debido al `await`, todas esas operaciones en cola aÃºn usarÃ¡n el valor inicial de sus variables, por lo que para que funcione correctamente, serÃ¡ necesario usar el valor anterior del renderizado pendiente.

Dentro del controlador de evento `handleClick`, los valores de `pending` y `completed` corresponden a lo que eran en el momento del evento de clic. Para el primer renderizado, `pending` era `0`, por lo que `setPending(pending - 1)` se convierte en `setPending(-1)`, lo cual es incorrecto. Como quieres _incrementar_ o _disminuir_ los contadores, en lugar de establecerlos a un valor concreto determinado durante el clic, puedes pasar las funciones de actualizaciÃ³n.

Esto asegura que cuando se incrementa o disminuye un contador, se hace con relaciÃ³n a su _Ãºltimo_ estado y no al valor del estado en el momento del clic:

**App.jsx**
```jsx
import { useState } from "react";

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending((pending) => pending - 1); // ğŸ‘ˆ
    setCompleted((completed) => completed + 1); // ğŸ‘ˆ
  }

  return (
    <>
      <h3>Pendiente: {pending}</h3>
      <h3>Completado: {completed}</h3>
      <button onClick={handleClick}>Comprar</button>
    </>
  );
}

function delay(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
```
## â­ DesafÃ­oÂ 2Â deÂ 2:Â Implementa la cola de estado tÃº mismo

Â¡En este reto, reimplementarÃ¡s una pequeÃ±a parte de React desde cero! No es tan difÃ­cil como parece.

DesplÃ¡zate por la vista previa del _sandbox_. Observa que muestra **cuatro casos de prueba.** Se corresponden con los ejemplos que has visto antes en esta pÃ¡gina. Tu tarea es implementar la funciÃ³n `getFinalState` para que devuelva el resultado correcto para cada uno de esos casos. Si la implementas correctamente, las cuatro pruebas deberÃ­an pasar.

RecibirÃ¡s dos argumentos: `baseState` es el estado inicial (como `0`), y la `queue` es un array que contiene una mezcla de nÃºmeros (como `5`) y funciones de actualizaciÃ³n (como `n => n + 1`) en el orden en que fueron aÃ±adidas.

Tu tarea es devolver el estado final, Â¡tal y como muestran las tablas de esta pÃ¡gina!

**processQueue.js**
```jsx
export function getFinalState(baseState, queue) {
  let finalState = baseState;

  // TODO: haz algo con la cola...

  return finalState;
}
```

### Respuesta

```jsx
export function getFinalState(baseState, queue) {
  let finalState = baseState;

  queue.forEach((updateValue) => { // ğŸ‘ˆ
    if (typeof updateValue === "number") { // ğŸ‘ˆ
      // Reemplaza el siguiente estado.
      finalState = updateValue; // ğŸ‘ˆ
    } else {
	  // Aplica la funciÃ³n de actualizaciÃ³n.
      finalState = updateValue(finalState); // ğŸ‘ˆ
    }
  });

  return finalState;
}
```