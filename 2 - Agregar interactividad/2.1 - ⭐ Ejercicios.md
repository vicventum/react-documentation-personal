## DesafÃ­oÂ 1Â deÂ 4:Â Completa la galerÃ­a

Cuando presionamos Â«SiguienteÂ» en la Ãºltima escultura, el cÃ³digo falla. Arregla la lÃ³gica para evitar el bloqueo. Puedes hacer esto agregando lÃ³gica adicional al controlador de evento o deshabilitando el botÃ³n cuando la acciÃ³n no es posible.

DespuÃ©s de arreglar el error, agrega un botÃ³n Â«AnteriorÂ» que muestre la escultura anterior. No deberÃ­a chocar con la primera escultura.

**App.js**
```jsx
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Siguiente
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        por {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} de {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Ocultar' : 'Mostrar'} detalles
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}
```

**data.js**
```jsx
export const sculptureList = [{
  name: 'Homenaje a la neurocirugÃ­a',
  artist: 'Marta Colvin Andrade',
  description: 'Aunque Colvin es predominantemente conocida por temas abstractos que aluden a sÃ­mbolos prehispÃ¡nicos, esta gigantesca escultura, un homenaje a la neurocirugÃ­a, es una de sus obras de arte pÃºblico mÃ¡s reconocibles.',
  url: 'https://i.imgur.com/Mx7dA2Y.jpg',
  alt: 'Una estatua de bronce de dos manos cruzadas sosteniendo delicadamente un cerebro humano en la punta de sus dedos.'
}, {
  name: 'Floralis genÃ©rica',
  artist: 'Eduardo Catalano',
  description: 'Esta enorme flor plateada (75 pies o 23 m) se encuentra en Buenos Aires. EstÃ¡ diseÃ±ado para moverse, cerrando sus pÃ©talos por la tarde o cuando soplan fuertes vientos y abriÃ©ndolos por la maÃ±ana.',
  url: 'https://i.imgur.com/ZF6s192m.jpg',
  alt: 'Una gigantesca escultura de flor metÃ¡lica con pÃ©talos reflectantes como espejos y fuertes estambres.'
}, {
  name: 'Presencia eterna',
  artist: 'John Woodrow Wilson',
  description: 'Wilson era conocido por su preocupaciÃ³n por la igualdad, la justicia social, asÃ­ como por las cualidades esenciales y espirituales de la humanidad. Este bronce masivo (7 pies o 2,13 m) representa lo que Ã©l describiÃ³ como "una presencia negra simbÃ³lica infundida con un sentido de humanidad universal"."',
  url: 'https://i.imgur.com/aTtVpES.jpg',
  alt: 'La escultura que representa una cabeza humana parece omnipresente y solemne. Irradia calma y serenidad.'
}]
```

### Respuesta

**App.jsx**
```jsx
import { useState } from "react";
import { sculptureList } from "./data.js";

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  const isEndPage = index < sculptureList.length - 1; // ğŸ‘ˆ
  const isStartPage = index > 0; // ğŸ‘ˆ

  function handleNextClick() {
    if (isEndPage) setIndex(index + 1); // ğŸ‘ˆ
  }
  function handlePrevClick() { // ğŸ‘ˆ
    if (isStartPage) setIndex(index - 1); // ğŸ‘ˆ
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick} disabled={!isEndPage}> // ğŸ‘ˆ
        Siguiente
      </button>
      <button onClick={handlePrevClick} disabled={!isStartPage}> // ğŸ‘ˆ
        Anterior
      </button>
      <h2>
        <i>{sculpture.name} </i>
        por {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} de {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? "Ocultar" : "Mostrar"} detalles
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img src={sculpture.url} alt={sculpture.alt} />
    </>
  );
}
```

## DesafÃ­oÂ 2Â deÂ 4:Â Arreglar entradas de formulario atascadas

Cuando escribimos en los campos del formulario, no obtenemos nada. Es como si los valores estuvieran Â«atascadosÂ» con cadenas vacÃ­as. El `valor` de la primera `<input>` estÃ¡ configurado para coincidir siempre con la variable `firstName`, y el `valor` de la segunda `<input>` estÃ¡ configurado para coincidir siempre con la variable `lastName`. Esto es correcto. Ambas entradas tienen controladores de eventos `onChange`, que intentan actualizar las variables en funciÃ³n de la Ãºltima entrada del usuario (`e.target.value`). Sin embargo, las variables no parecen Â«_recordar_Â» sus valores entre renderizaciones. Solucionemos esto usando variables de estado en su lugar.

**App.jsx**
```jsx
export default function Form() {
  let firstName = '';
  let lastName = '';

  function handleFirstNameChange(e) {
    firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    lastName = e.target.value;
  }

  function handleReset() {
    firstName = '';
    lastName = '';
  }

  return (
    <form onSubmit={e => e.preventDefault()}>
      <input
        placeholder="Nombre"
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder="Apellido"
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>Hola, {firstName} {lastName}</h1>
      <button onClick={handleReset}>Reiniciar</button>
    </form>
  );
}
```

### Respuesta

**App.jsx**
```jsx
import { useState } from "react"; // ğŸ‘ˆ

export default function Form() {
  const [firstName, setFirstName] = useState(""); // ğŸ‘ˆ
  const [lastName, setLastName] = useState(""); // ğŸ‘ˆ

  function handleFirstNameChange(e) {
    setFirstName(e.target.value); // ğŸ‘ˆ
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value); // ğŸ‘ˆ
  }

  function handleReset() {
    setFirstName(""); // ğŸ‘ˆ
    setLastName(""); // ğŸ‘ˆ
  }

  return (
    <form onSubmit={(e) => e.preventDefault()}>
      <input
        placeholder="Nombre"
        value={firstName}
        onChange={handleFirstNameChange}
      />
      <input
        placeholder="Apellido"
        value={lastName}
        onChange={handleLastNameChange}
      />
      <h1>
        Hola, {firstName} {lastName}
      </h1>
      <button onClick={handleReset}>Reiniciar</button>
    </form>
  );
}
```

## DesafÃ­oÂ 3Â deÂ 4:Â Arregla un error

AquÃ­ hay un pequeÃ±o formulario que se supone que permite al usuario dejar algunos comentarios. Cuando se envÃ­a el comentario, se supone que debe mostrar un mensaje de agradecimiento. Sin embargo, falla con un mensaje de error que dice Â«_Se generaron menos Hooks de los esperados_Â». Â¿Puedes detectar el error y corregirlo?

**App.jsx**
```jsx
import { useState } from 'react';

export default function FeedbackForm() {
  const [isSent, setIsSent] = useState(false);
  if (isSent) {
    return <h1>Â¡Gracias!</h1>;
  } else {
    // eslint-disable-next-line
    const [message, setMessage] = useState('');
    return (
      <form onSubmit={e => {
        e.preventDefault();
        alert(`Enviando: "${message}"`);
        setIsSent(true);
      }}>
        <textarea
          placeholder="Mensaje"
          value={message}
          onChange={e => setMessage(e.target.value)}
        />
        <br />
        <button type="submit">Enviar</button>
      </form>
    );
  }
}
```

### Respuesta

Los Hooks solo se pueden llamar en el nivel superior de un componente. AquÃ­, la primera definiciÃ³n `isSent` sigue esta regla, pero la definiciÃ³n `message` estÃ¡ anidada en una condiciÃ³n.

Moverlo fuera de la condiciÃ³n para solucionar el problema:

**App.js**
```jsx
import { useState } from "react";

export default function FeedbackForm() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState(""); // ğŸ‘ˆ

  if (isSent) {
    return <h1>Â¡Gracias!</h1>;
  } else {
    return (
      <form
        onSubmit={(e) => {
          e.preventDefault();
          alert(`Enviando: "${message}"`);
          setIsSent(true);
        }}
      >
        <textarea
          placeholder="Mensaje"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
        <br />
        <button type="submit">Enviar</button>
      </form>
    );
  }
}

```
## â­ DesafÃ­oÂ 4Â deÂ 4:Â Eliminar estado innecesario

Cuando se hace clic en el botÃ³n, este ejemplo debe solicitar el nombre del usuario y luego mostrar una alerta saludÃ¡ndolo. Intentaste usar el estado para mantener el nombre, pero por alguna razÃ³n siempre muestra Â«Â¡Hola!Â«.

Para corregir este cÃ³digo, elimina la variable de estado innecesaria. (Discutiremos sobre [por quÃ© esto no funcionÃ³](https://es.react.dev/learn/state-as-a-snapshot)  mÃ¡s adelante en [[4 - â­ El estado como una instantÃ¡nea|esta lecciÃ³n]]).

Â¿Puede explicar por quÃ© esta variable de estado era innecesaria?

**App.jsx**
```jsx
import { useState } from 'react';

export default function FeedbackForm() {
  const [name, setName] = useState('');

  function handleClick() {
    setName(prompt('Â¿CuÃ¡l es tu nombre?'));
    alert(`Hola, ${name}!`);
  }

  return (
    <button onClick={handleClick}>
      Saludar
    </button>
  );
}
```

### Respuesta

==El problema estÃ¡ en que si bien sÃ­ se guarda correctamente el valor en el estado de `name`, como aÃºn no se ha realizado un nuevo renderizado, para el momento en donde se usa dicha variable su valor aÃºn no ha cambiado, debido que no se ha producido un nuevo renderizado aÃºn==.

AquÃ­ estÃ¡ la versiÃ³n con la soluciÃ³n que usa una variable `name` regular declarada en la funciÃ³n que la necesita:

**App.jsx**
```jsx
export default function FeedbackForm() {
  function handleClick() {
    const name = prompt('Â¿CuÃ¡l es tu nombre?'); // ğŸ‘ˆ
    alert(`Hola, ${name}!`);
  }

  return (
    <button onClick={handleClick}>
      Saludar
    </button>
  );
}
```

**Una variable de estado solo es necesaria para mantener la informaciÃ³n entre renderizaciones de un componente**. Dentro de un solo controlador de evento, una variable regular funcionarÃ¡ bien. Es recomendable no usar variables de estado cuando una variable regular funciona bien.