## DesafÃ­oÂ 1Â deÂ 4:Â Arreglar un componente que no se actualiza

Este componente `Reloj` recibe dos props: `color` y `tiempo`. Cuando seleccionas un color diferente en el cuadro de selecciÃ³n, el componente `Reloj` recibe una prop de `color` diferente de su componente principal. Sin embargo, por alguna razÃ³n, el color mostrado no se actualiza. Â¿Por quÃ©? Arregla el problema.

**Clock.js**
```jsx
import { useState } from 'react';

export default function Clock(props) {
  const [color, setColor] = useState(props.color);
  return (
    <h1 style={{ color: color }}>
      {props.time}
    </h1>
  );
}
```

Muestra: 

![[2.1-eleccion-de-la-estructura-del-estado-1.png]]

### Respuesta

El problema es que este componente tiene un estado de `color` inicializado con el valor inicial de la prop `color`. Pero cuando cambia la prop `color`, Â¡esto no afecta la variable de estado! Entonces se desincronizan. Para solucionar este problema, elimina la variable de estado por completo y use la prop `color` directamente.

**Clock.jsx**
```jsx
export default function Clock({ color, time }) { // ðŸ‘ˆ
  return <h1 style={{ color }}>{time}</h1>; // ðŸ‘ˆ
}
```

## DesafÃ­oÂ 2Â deÂ 4:Â Arreglar una lista de empaque rota

Esta lista de empaque tiene un pie de pÃ¡gina que muestra cuÃ¡ntos artÃ­culos estÃ¡n empacados y cuÃ¡ntos artÃ­culos hay en total. Al principio parece funcionar, pero tiene errores. Por ejemplo, si marcas un artÃ­culo como empaquetado y luego lo eliminas, el contador no se actualizarÃ¡ correctamente. Arregla el contador para que estÃ© siempre correcto.

### Respuesta

Aunque podrÃ­as cambiar cuidadosamente cada controlador de evento para actualizar correctamente los contadores `total` y `packed`, el problema principal es que estas variables de estado existan desde un inicio. Son redundantes porque siempre se puede calcular el nÃºmero de elementos (empaquetados o totales) a partir de la propia matriz `items`. Elimine el estado redundante para corregir el error:

**App.jsx**
```jsx
import { useState } from "react";
import AddItem from "./AddItem.js";
import PackingList from "./PackingList.js";

const initialItems = [
  { id: 0, title: "Calcetines cÃ¡lidos", packed: true },
  { id: 1, title: "Diario de viaje", packed: false },
  { id: 2, title: "Acuarelas", packed: false },
];

export default function TravelPlan() {
  const [items, setItems] = useState(initialItems);
  const total = items.length; // ðŸ‘ˆ
  const packed = items.filter(({ packed }) => packed).length; // ðŸ‘ˆ

  function handleAddItem(title) {
    setItems([
      ...items,
      {
        id: items.length++, // ðŸ‘ˆ
        title: title,
        packed: false,
      },
    ]);
  }

  function handleChangeItem(nextItem) {
    setItems(
      items.map((item) => {
        if (item.id === nextItem.id) {
          return nextItem;
        } else {
          return item;
        }
      })
    );
  }

  function handleDeleteItem(itemId) {
    setItems(items.filter((item) => item.id !== itemId));
  }

  return (
    <>
      <AddItem onAddItem={handleAddItem} />
      <PackingList
        items={items}
        onChangeItem={handleChangeItem}
        onDeleteItem={handleDeleteItem}
      />
      <hr />
      <b>
        Â¡{packed} de {total} empacados! // ðŸ‘ˆ
      </b>
    </>
  );
}
```

## DesafÃ­oÂ 3Â deÂ 4:Â Reparar la selecciÃ³n que desapareceÂ 

Hay una lista de `letters` en el estado. Cuando se pasa el ratÃ³n o se enfoca una carta en particular, Ã©sta se resalta. La carta resaltada actualmente se almacena en la variable de estado `highlightedLetter`. Puedes Â«marcarÂ» y Â«desmarcarÂ» cartas individuales, lo que actualiza el _array_ de `letters` en el estado.

Este cÃ³digo funciona, pero hay un pequeÃ±o fallo en la UI. Cuando presionas Â«MarcarÂ» o Â«DesmarcarÂ», el resaltado desaparece por un momento. Sin embargo, reaparece en cuanto mueves el puntero o cambias a otra carta con el teclado. Â¿Por quÃ© ocurre esto? ArrÃ©glalo para que el resaltado no desaparezca despuÃ©s de hacer clic en el botÃ³n.

**App.jsx**
```jsx
import { useState } from 'react';
import { initialLetters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [letters, setLetters] = useState(initialLetters);
  const [highlightedLetter, setHighlightedLetter] = useState(null);

  function handleHover(letter) {
    setHighlightedLetter(letter);
  }

  function handleStar(starred) {
    setLetters(letters.map(letter => {
      if (letter.id === starred.id) {
        return {
          ...letter,
          isStarred: !letter.isStarred
        };
      } else {
        return letter;
      }
    }));
  }

  return (
    <>
      <h2>BuzÃ³n de entrada</h2>
      <ul>
        {letters.map(letter => (
          <Letter
            key={letter.id}
            letter={letter}
            isHighlighted={
              letter === highlightedLetter
            }
            onHover={handleHover}
            onToggleStar={handleStar}
          />
        ))}
      </ul>
    </>
  );
}
```

**Letter.jsx**
```jsx
export default function Letter({
  letter,
  isHighlighted,
  onHover,
  onToggleStar,
}) {
  return (
    <li
      className={
        isHighlighted ? 'highlighted' : ''
      }
      onFocus={() => {
        onHover(letter);
      }}
      onPointerMove={() => {
        onHover(letter);
      }}
    >
      <button onClick={() => {
        onToggleStar(letter);
      }}>
        {letter.isStarred ? 'Desmarcar' : 'Marcar'}
      </button>
      {letter.subject}
    </li>
  )
}
```

**data.js**
```js
export const initialLetters = [{
  id: 0,
  subject: 'Â¿Listo para la aventura?',
  isStarred: true,
}, {
  id: 1,
  subject: 'Â¡Hora de registrarse!',
  isStarred: false,
}, {
  id: 2,
  subject: 'Â¡El festival comienza en solo SIETE dÃ­as!',
  isStarred: false,
}];
```

Al hacer hover:

![[2.1-eleccion-de-la-estructura-del-estado-3.png]]

Al hacer click:

![[2.1-eleccion-de-la-estructura-del-estado-4.png]]

### Respuesta

El problema es que estÃ¡s manteniendo el objeto carta en `highlightedLetter`. Pero tambiÃ©n estÃ¡s guardando la misma informaciÃ³n en el _array_ `letters`. AsÃ­ que tu estado estÃ¡ duplicado. Cuando actualizas el _array_ `letters` despuÃ©s de pulsar el botÃ³n, creas un nuevo objeto carta que es diferente de `highlightedLetter`. Esta es la razÃ³n por la que la verificaciÃ³n `highlightedLetter === letter` se convierte en `false`, y el resaltado desaparece. ReaparecerÃ¡ la prÃ³xima vez que llames a `setHighlightedLetter` cuando el puntero se mueva.

Para solucionar el problema, elimina la duplicaciÃ³n del estado. En lugar de almacenar _la propia carta_ en dos lugares, almacena el `highlightedId` en su lugar. Entonces puedes comprobar `isHighlighted` para cada carta con `letter.id === highlightedId`, lo que funcionarÃ¡ incluso si el objeto `letter` ha cambiado desde el Ãºltimo renderizado.

**App.jsx**
```jsx
import { useState } from 'react';
import { initialLetters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [letters, setLetters] = useState(initialLetters);
  const [highlightedId, setHighlightedId ] = useState(null); // ðŸ‘ˆ

  function handleHover(letterId) { // ðŸ‘ˆ
    setHighlightedId(letterId); // ðŸ‘ˆ
  }

  function handleStar(starredId) {
    setLetters(letters.map(letter => {
      if (letter.id === starredId) {
        return {
          ...letter,
          isStarred: !letter.isStarred
        };
      } else {
        return letter;
      }
    }));
  }

  return (
    <>
      <h2>BuzÃ³n de entrada</h2>
      <ul>
        {letters.map(letter => (
          <Letter
            key={letter.id}
            letter={letter}
            isHighlighted={
              letter.id === highlightedId // ðŸ‘ˆ
            }
            onHover={handleHover}
            onToggleStar={handleStar}
          />
        ))}
      </ul>
    </>
  );
}

```

**Letter.jsx**
```jsx
export default function Letter({
  letter,
  isHighlighted,
  onHover,
  onToggleStar,
}) {
  return (
    <li
      className={
        isHighlighted ? 'highlighted' : ''
      }
      onFocus={() => {
        onHover(letter.id); // ðŸ‘ˆ
      }}
      onPointerMove={() => {
        onHover(letter.id); // ðŸ‘ˆ
      }}
    >
      <button onClick={() => {
        onToggleStar(letter.id);
      }}>
        {letter.isStarred ? 'Desmarcar' : 'Marcar'}
      </button>
      {letter.subject}
    </li>
  )
}
```

## DesafÃ­oÂ 3Â deÂ 4:Â Reparar la selecciÃ³n que desapareceÂ 

En este ejemplo, cada Letter tiene una propiedad isSelected y un controlador onToggle que la marca como seleccionada. Esto funciona, pero el estado se almacena como un selectedId (ya sea null o un ID), por lo que solo se puede seleccionar una carta en un momento dado.

Cambia la estructura de estado para admitir la selecciÃ³n mÃºltiple. (Â¿CÃ³mo lo estructurarÃ­as? Piensa en esto antes de escribir el cÃ³digo). Cada casilla de verificaciÃ³n debe independizarse de las demÃ¡s. Al hacer clic en una carta seleccionada, deberÃ­a desmarcarse. Por Ãºltimo, el pie de pÃ¡gina debe mostrar el nÃºmero correcto de los elementos seleccionados.

**App.jsx**
```jsx
import { useState } from 'react';
import { letters } from './data.js';
import Letter from './Letter.js';

export default function MailClient() {
  const [selectedId, setSelectedId] = useState(null);

  // TODO: permitir selecciÃ³n mÃºltiple
  const selectedCount = 1;

  function handleToggle(toggledId) {
    // TODO: permitir selecciÃ³n mÃºltiple
    setSelectedId(toggledId);
  }

  return (
    <>
      <h2>BuzÃ³n de entrada</h2>
      <ul>
        {letters.map(letter => (
          <Letter
            key={letter.id}
            letter={letter}
            isSelected={
              // TODO: permitir selecciÃ³n mÃºltiple
              letter.id === selectedId
            }
            onToggle={handleToggle}
          />
        ))}
        <hr />
        <p>
          <b>
            Has seleccionado {selectedCount} cartas
          </b>
        </p>
      </ul>
    </>
  );
}
```

**Letters.jsx**
```jsx
export default function Letter({
  letter,
  onToggle,
  isSelected,
}) {
  return (
    <li className={
      isSelected ? 'selected' : ''
    }>
      <label>
        <input
          type="checkbox"
          checked={isSelected}
          onChange={() => {
            onToggle(letter.id);
          }}
        />
        {letter.subject}
      </label>
    </li>
  )
}
```

**data.js**
```js
export const letters = [{
  id: 0,
  subject: 'Â¿Listo para la aventura?',
  isStarred: true,
}, {
  id: 1,
  subject: 'Â¡Hora de registrarse!',
  isStarred: false,
}, {
  id: 2,
  subject: 'Â¡El festival comienza en solo SIETE dÃ­as!',
  isStarred: false,
}];
```

Muestra:

![[2.1-eleccion-de-la-estructura-del-estado-5.png]]

### Respuesta

En lugar de un solo `selectedId`, mantÃ©n un _array_ `selectedIds` en el estado. Por ejemplo, si selecciona la primera y la Ãºltima carta, contendrÃ­a `[0, 2]`. Cuando no se selecciona nada, serÃ­a un _array_ `[]` vacÃ­o:

**App.jsx**
```jsx
import { useState } from "react";
import { letters } from "./data.js";
import Letter from "./Letter.js";

export default function MailClient() {
  const [selectedIds, setSelectedIds] = useState([]);

  function handleToggle(toggledId) {
    const hasId = selectedIds.includes(toggledId); // ðŸ‘ˆ
    setSelectedIds( // ðŸ‘ˆ
      hasId // ðŸ‘ˆ
        ? selectedIds.filter((id) => id !== toggledId)
        : selectedIds.concat(toggledId)
    );
  }

  return (
    <>
      <h2>BuzÃ³n de entrada</h2>
      <ul>
        {letters.map((letter) => (
          <Letter
            key={letter.id}
            letter={letter}
            isSelected={
              selectedIds.includes(letter.id) // ðŸ‘ˆ
            }
            onToggle={handleToggle}
          />
        ))}
        <hr />
        <p>
          <b>Has seleccionado {selectedIds.length} cartas</b> // ðŸ‘ˆ
        </p>
      </ul>
    </>
  );
}

```
```jsx

```