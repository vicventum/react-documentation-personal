## DesafÃ­oÂ 1Â deÂ 4:Â Despachar actions desde controladores de eventos

Actualmente, los controladores de eventos en `ContactList.js` y `Chat.js` tienen comentarios `// TODO`. Esta es la razÃ³n por la que escribir en el input no funciona, y hacer clic sobre los botones no cambia el destinatario seleccionado.

Reemplaza estos dos `// TODO`s con el cÃ³digo para hacer `dispatch` de las actions correspondientes. Para ver la forma y el tipo (_type_) esperados de las acciones, revisa el reducer en `messengerReducer.js`. El reducer ya estÃ¡ escrito, asÃ­ que no necesitas cambiarlo. Solo tendrÃ¡s que despachar las acciones en `ContactList.js` y `Chat.js`.

**App.jsx**
```jsx
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

**messengerReduce.js**
```js
export const initialState = {
  selectedId: 0,
  message: 'Hola',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

**ContactList.jsx**
```jsx
export default function ContactList({contacts, selectedId, dispatch}) {
  return (
    <section className="contact-list">
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                // TODO: Despachar changed_selection // ðŸ‘ˆ
              }}>
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

**Chat.jsx**
```jsx
import { useState } from 'react';

export default function Chat({contact, message, dispatch}) {
  return (
    <section className="chat">
      <textarea
        value={message}
        placeholder={'Chatear con ' + contact.name}
        onChange={(e) => {
          // TODO: Despachar edited_message // ðŸ‘ˆ
          // (Lee el valor del input en e.target.value)
        }}
      />
      <br />
      <button>Enviar a {contact.email}</button>
    </section>
  );
}
```

Al pulsar sobre otro contacto o tratar de modificar el texto en el input no realiza ninguna acciÃ³n:

![[5.1-extraer-lÃ³gica-de-estado-en-un-reducer-1.png]]

### Respuesta

Por el cÃ³digo del reducer, puedes inferir que las acciones necesitan verse asÃ­:

```js
// Cuando el usuario presiona "Alice"
dispatch({
  type: 'changed_selection',
  contactId: 1,
});

// Cuando el usuario escribe "Â¡Hola!"
dispatch({
  type: 'edited_message',
  message: 'Â¡Hola!',
});
```

AquÃ­ hay un ejemplo actualizado para despachar los mensajes correspondientes:

**App.jsx**
```jsx
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

**messengerReduce.js**
```js
export const initialState = {
  selectedId: 0,
  message: 'Hola',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

**ContactList.jsx**
```jsx
export default function ContactList({contacts, selectedId, dispatch}) {
  return (
    <section className="contact-list">
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                // TODO: Despachar changed_selection
                dispatch({ // ðŸ‘ˆ
                  type: "changed_selection",
                  contactId: contact.id
                });
              }}>
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

**Chat.jsx**
```jsx
import { useState } from 'react';

export default function Chat({contact, message, dispatch}) {
  return (
    <section className="chat">
      <textarea
        value={message}
        placeholder={'Chatear con ' + contact.name}
        onChange={(e) => {
          // TODO: Despachar edited_message
          // (Lee el valor del input en e.target.value)
          dispatch({ // ðŸ‘ˆ
            type: "edited_message",
            message: e.target.value
          });
        }}
      />
      <br />
      <button>Enviar a {contact.email}</button>
    </section>
  );
}
```

## DesafÃ­oÂ 2Â deÂ 4:Â Limpiar el input al enviar un mensajeÂ 

Actualmente, si se presiona Â«EnviarÂ» no pasa nada. Agrega un controlador de evento al botÃ³n de Â«EnviarÂ» que va a:

1. Mostrar unÂ `alert`Â con el correo del destinatario y el mensaje.
2. Limpiar el input del mensaje.

**App.jsx**
```jsx
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

**messengerReduce.js**
```js
export const initialState = {
  selectedId: 0,
  message: 'Hola',
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': {
      return {
        ...state,
        message: action.message,
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

**ContactList.jsx**
```jsx
export default function ContactList({contacts, selectedId, dispatch}) {
  return (
    <section className="contact-list">
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                  type: "changed_selection",
                  contactId: contact.id
                });
              }}>
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

**Chat.jsx**
```jsx
import { useState } from 'react';

export default function Chat({contact, message, dispatch}) {
  return (
    <section className="chat">
      <textarea
        value={message}
        placeholder={'Chatear con ' + contact.name}
        onChange={(e) => {
            type: "edited_message",
            message: e.target.value
          });
        }}
      />
      <br />
      <button>Enviar a {contact.email}</button>
    </section>
  );
}
```

### Respuesta

Hay un par de maneras de hacerlo en el controlador de evento del botÃ³n de Â«EnviarÂ». Un enfoque es mostrar una alerta y luego despachar una acciÃ³n `edited_message` con un `message` vacÃ­o.

Esto funciona y limpia el input cuando se presiona Â«EnviarÂ»

Sin embargo, _desde la perspectiva del usuario_, enviar un mensaje es una acciÃ³n diferente a editar un campo. Para reflejar esto, puedes crear en su lugar una _nueva_ acciÃ³n llamada `sent_message`, y manejarla de manera separada en el reducer.

El comportamiento resultante es el mismo. Pero ten en mente que **los tipos de las acciones deberÃ­an idealmente describir Â«quÃ© hizo el usuarioÂ» mÃ¡s que Â«cÃ³mo quieres que el estado cambieÂ»**. Esto simplifica agregar luego mÃ¡s funcionalidades.

Con cualquiera de las dos soluciones, es importante que **no** coloques la `alert` dentro de un reducer. El reducer debe ser una funciÃ³n puraâ€”solo debe calcular el siguiente estado. No deberÃ­a Â«hacerÂ» nada, incluyendo mostrar mensajes al usuario. Eso deberÃ­a suceder en el controlador de evento. (Para ayudar a detectar errores como este, React llamarÃ¡ a tus reducers varias veces en el Modo Estricto. Es por eso que, si colocas una alerta en un reducer, se llama dos veces).

**messengerReducer.js**
```js
export const initialState = {
  selectedId: 0,
  message: "Hola"
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case "changed_selection": {
      return {
        ...state,
        selectedId: action.contactId,
        message: ""
      };
    }
    case "edited_message": {
      return {
        ...state,
        message: action.message
      };
    }
    case "send_message": { // ðŸ‘ˆ
      return {
        ...state,
        message: ""
      };
    }
    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}
```

**Chat.jsx**
```jsx
import { useState } from "react";

export default function Chat({ contact, message, dispatch }) {
  function handleSubmit(e) { // ðŸ‘ˆ
    e.preventDefault();
    alert(`Enviando "${message}" a ${contact.email}`);
    dispatch({
      type: "send_message"
    });
  }

  return (
    <form className="chat" onSubmit={handleSubmit}> // ðŸ‘ˆ
      <textarea
        value={message}
        placeholder={"Chatear con " + contact.name}
        onChange={(e) => {
          dispatch({
            type: "edited_message",
            message: e.target.value
          });
        }}
      />
      <br />
      <button>Enviar a {contact.email}</button>
    </form>
  );
}
```

## DesafÃ­oÂ 3Â deÂ 4:Â Restaurar valores de input al cambiar entre pestaÃ±as

En este ejemplo, cambiar entre diferentes destinatarios siempre limpia el input de texto:

```js
case 'changed_selection': {
  return {
    ...state,
    selectedId: action.contactId,
    message: '' // Limpia el input
  };
```
Esto ocurre porque no quieres compartir un solo borrador de mensaje entre varios destinatarios. Pero serÃ­a mejor si tu aplicaciÃ³n Â«recordaraÂ» un borrador para cada contacto separadamente, restaurÃ¡ndolos cuando cambias contactos.

Tu tarea es cambiar la manera en la que el estado estÃ¡ estructurado asÃ­ se puede recordar un borrador de mensaje separado _por contacto_. TendrÃ¡s que hacer algunos cambios al reducer, al estado inicial y a los componentes.


**App.jsx**
```jsx
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

**messengerReducer.js**
```js
export const initialState = {
  selectedId: 0,
  message: "Hola"
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case "changed_selection": {
      return {
        ...state,
        selectedId: action.contactId,
        message: ""{ // ðŸ‘ˆ
      };
    }
    case "edited_message": {
      return {
        ...state,
        message: action.message
      };
    }
    case "send_message": 
      return {
        ...state,
        message: ""
      };
    }
    default: {
      throw Error("Unknown action: " + action.type);
    }
  }
}
```

**Chat.jsx**
```jsx
import { useState } from "react";

export default function Chat({ contact, message, dispatch }) {
  function handleSubmit(e) { 
    e.preventDefault();
    alert(`Enviando "${message}" a ${contact.email}`);
    dispatch({
      type: "send_message"
    });
  }

  return (
    <form className="chat" onSubmit={handleSubmit}> 
      <textarea
        value={message}
        placeholder={"Chatear con " + contact.name}
        onChange={(e) => {
          dispatch({
            type: "edited_message",
            message: e.target.value
          });
        }}
      />
      <br />
      <button>Enviar a {contact.email}</button>
    </form>
  );
}
```

**ContactList.jsx**
```jsx
export default function ContactList({contacts, selectedId, dispatch}) {
  return (
    <section className="contact-list">
      <ul>
        {contacts.map((contact) => (
          <li key={contact.id}>
            <button
              onClick={() => {
                dispatch({ 
                  type: "changed_selection",
                  contactId: contact.id
                });
              }}>
              {selectedId === contact.id ? <b>{contact.name}</b> : contact.name}
            </button>
          </li>
        ))}
      </ul>
    </section>
  );
}
```

### Respuesta

NecesitarÃ¡s actualizar el reducer para guardar y actualizar un borrador de mensaje separado por contacto:

```jsx
// Cuando se edita el input
case 'edited_message': {
  return {
    // MantÃ©n otro estado como el id seleccionado
    ...state,
    messages: {
      // MantÃ©n los mensajes de otros contactos
      ...state.messages,
      // Pero cambia el mensaje del contacto seleccionado
      [state.selectedId]: action.message
    }
  };
}
```

TambiÃ©n actualizarÃ­as el componente `Messenger` de modo que lea el mensaje para el contacto actualmente seleccionado:

```js
const message = state.messages[state.selectedId];
```

Esta es la soluciÃ³n completa:

**App.jsx**
```jsx
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.messages[state.selectedId]; // ðŸ‘ˆ
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

**messengerReducer.js**
```jsx
export const initialState = {
  selectedId: 0,
  messages: { // ðŸ‘ˆ
    0: 'Hola, Taylor', // Borrador para contactId = 0
    1: 'Hola, Alice', // Borrador para contactId = 1
  },
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
        message: '',
      };
    }
    case 'edited_message': { // ðŸ‘ˆ
      return {
        // MantÃ©n otro estado como el id seleccionado
        ...state,
        messages: {
          // MantÃ©n los mensajes de otros contactos
          ...state.messages,
          // Pero cambia el mensaje del contacto seleccionado
          [state.selectedId]: action.message
        }
      };
    }
    case 'sent_message': {
      return {
        ...state,
        message: '',
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

En particular, no necesitas cambiar ninguno de los controladores de eventos para implementar este comportamiento diferente. Sin un reducer, necesitarÃ­as tener que cambiar cada controlador de evento que actualice el estado.

## DesafÃ­oÂ 4Â deÂ 4:Â ImplementarÂ `useReducer`Â desde cero

En los ejemplos anteriores, importaste el Hook `useReducer` desde React. Â¡Esta vez, vas a implementar _el propio Hook `useReducer`!_. AquÃ­ tienes algo para empezar. No deberÃ­a tomar mÃ¡s de 10 lÃ­neas de cÃ³digo.

Para probar tus cambios, intenta escribir en el input o seleccionar un contacto.

**App.jsx**
```jsx
import { useReducer } from './MyReact.js';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.messages[state.selectedId];
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

**messengerReducer.js**
```js
export const initialState = {
  selectedId: 0,
  messages: {
    0: 'Hola, Taylor',
    1: 'Hola, Alice',
    2: 'Hola, Bob',
  },
};

export function messengerReducer(state, action) {
  switch (action.type) {
    case 'changed_selection': {
      return {
        ...state,
        selectedId: action.contactId,
      };
    }
    case 'edited_message': {
      return {
        ...state,
        messages: {
          ...state.messages,
          [state.selectedId]: action.message,
        },
      };
    }
    case 'sent_message': {
      return {
        ...state,
        messages: {
          ...state.messages,
          [state.selectedId]: '',
        },
      };
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

**MyReact.js**
```js
import { useState } from 'react';

export function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  // ??? // ðŸ‘ˆ

  return [state, dispatch];
}
```

### Respuesta

Despachar una acciÃ³n llama al reducer con el estado actual y la acciÃ³n, y guarda el resultado como el siguiente estado. AsÃ­ es como se ve en cÃ³digo:

**MyReact.js**
```js
import { useState } from 'react';

export function useReducer(reducer, initialState) {
  const [state, setState] = useState(initialState);

  function dispatch(action) { // ðŸ‘ˆ
    const nextState = reducer(state, action);
    setState(nextState);
  }

  return [state, dispatch];
}
```

![[5.1-extraer-lÃ³gica-de-estado-en-un-reducer-1.png]]

Aunque no importa en la mayorÃ­a de los casos, una implementaciÃ³n ligeramente mÃ¡s acertada serÃ­a esta:

```js
function dispatch(action) {
  setState((s) => reducer(s, action));
}
```

Esto es porque las acciones despachadas se ponen en cola hasta el siguiente renderizado, [de forma similar a las funciones actualizadoras.](https://es.react.dev/learn/queueing-a-series-of-state-updates)