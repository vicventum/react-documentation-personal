El estado est√° aislado entre los componentes. **React mantiene un registro de qu√© estado pertenece a qu√© componente bas√°ndose en su lugar en el √°rbol de la interfaz de usuario (_UI_)**. Puedes controlar cu√°ndo preservar el estado y cu√°ndo reiniciarlo entre rerenderizados.

### Aprender√°s

- Cuando React elige preservar o restablecer el estado
- C√≥mo forzar a React a restablecer el estado del componente
- C√≥mo las _keys_ y los tipos afectan la preservaci√≥n del estado.

## ‚≠ê El estado est√° atado a la posici√≥n en el √°rbol de renderizado

React construye [√°rboles de renderizado](https://es.react.dev/learn/understanding-your-ui-as-a-tree#the-render-tree) para la estructura de componentes en tu UI.

Cuando le das estado a tu componente, podr√≠as pensar que el estado ¬´vive¬ª dentro del componente. Pero el estado en realidad se guarda dentro de React. **React asocia cada pieza de estado que mantiene con el componente correcto por la posici√≥n en la que se encuentra ese componente en el √°rbol de renderizado**.

En este caso, s√≥lo hay una etiqueta JSX `<Counter />`, pero se representa en dos posiciones diferentes:

**App.js**
```jsx
import { useState } from 'react';

export default function App() {
  const counter = <Counter />;
  return (
    <div>
      {counter}
      {counter}
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```

Muestra:

![[4-perservar-y-reiniciar-el-estado-1.png]]

Al pulsar un bot√≥n, s√≥lo se actualiza un componente, pese a que se est√°n instanciando 2 veces el mismo componente:

![[4-perservar-y-reiniciar-el-estado-2.png]]

Esta ser√≠a la apariencia del √°rbol:

![[4-perservar-y-reiniciar-el-estado-3.webp|600]]
>√Årbol de React

**Son dos contadores separados porque cada uno se renderiza en su propia posici√≥n en el √°rbol.** Normalmente no tienes que pensar en estas posiciones para usar React, pero puede ser √∫til para entender c√≥mo funciona.

**En React, cada componente en la pantalla tiene un estado totalmente aislado**. Por ejemplo, si renderizas dos componentes `Counter`, uno al lado del otro, cada uno de ellos obtendr√° sus propios e independientes estados `score` y `hover`.

Prueba a hacer clic en ambos contadores y observa que no se afectan mutuamente:

**App.jsx**
```jsx
import { useState } from 'react';

export default function App() {
  return (
    <div>
      <Counter />
      <Counter />
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```
Muestra:

![[4-perservar-y-reiniciar-el-estado-1.png]]

Al pulsar un bot√≥n, s√≥lo se actualiza un componente, pese a que se est√°n instanciando 2 veces el mismo componente:

![[4-perservar-y-reiniciar-el-estado-2.png]]

Como puedes ver, cuando se actualiza un contador, s√≥lo se actualiza el estado de ese componente:

![[4-perservar-y-reiniciar-el-estado-4.webp|600]]
> Actualizaci√≥n del estado

**React mantendr√° el estado mientras se renderice el mismo componente en la misma posici√≥n en el √°rbol**. Para ver esto, incrementa ambos contadores, luego quita el segundo componente desmarcando la casilla ¬´Renderizar el segundo contador¬ª, y luego vuelve a a√±adirlo marc√°ndola de nuevo:

**App.js**
```jsx
import { useState } from 'react';

export default function App() {
  const [showB, setShowB] = useState(true);
  return (
    <div>
      <Counter />
      {showB && <Counter />} 
      <label>
        <input
          type="checkbox"
          checked={showB}
          onChange={e => {
            setShowB(e.target.checked)
          }}
        />
        Renderizar el segundo contador
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```

Muestra:

![[4-perservar-y-reiniciar-el-estado-5.png]]

Al agregar uno en el segundo contador:

![[4-perservar-y-reiniciar-el-estado-6.png]]

Al borrar deshabilitar el segundo contador pulsando en la casilla:

![[4-perservar-y-reiniciar-el-estado-7.png]]

Al volver a habilitar el segundo contador vemos como el estado se ha reiniciado:

![[4-perservar-y-reiniciar-el-estado-8.png]]

**Observa c√≥mo en el momento en que dejas de renderizar el segundo contador, su estado desaparece por completo. Eso es porque cuando React elimina un componente, destruye su estado.**

![[4-perservar-y-reiniciar-el-estado-9.webp|500]]
>Eliminaci√≥n de un componente

Al marcar ¬´Renderizar el segundo contador¬ª, se inicializa un segundo `Counter` y su estado se inicializa desde cero (`score = 0`) y se a√±ade al DOM.

![[4-perservar-y-reiniciar-el-estado-10.webp|500]]
>A√±adiendo un componente

**React preserva el estado de un componente mientras se renderiza en su posici√≥n en el √°rbol de la interfaz de usuario. Si se elimina, o se renderiza un componente diferente en la misma posici√≥n, React descarta su estado**.

## ‚≠ê El mismo componente en la misma posici√≥n preserva el estado¬†

En este ejemplo, hay dos tipos diferentes de etiquetas `<Counter />`:

**App.js**
```jsx
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <Counter isFancy={true} /> // üëà
      ) : (
        <Counter isFancy={false} />  // üëà
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Usar un estilo elegante
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}

```
Muestra:

![[4-perservar-y-reiniciar-el-estado-11.png]]

Al agregar uno:

![[4-perservar-y-reiniciar-el-estado-12.png]]

Al agregar otro pero esta vez marcando la casilla:

![[4-perservar-y-reiniciar-el-estado-13.png]]

**Cuando se marca o desactiva la casilla, el estado del contador no se reinicia**. Tanto si `isFancy` es `true` como si es `false`, siempre tendr√°s un `<Counter />` como primer hijo del `div` devuelto desde el componente ra√≠z `App`:

![[4-perservar-y-reiniciar-el-estado-14.webp|550]]

**La actualizaci√≥n del estado de la `App` no reinicia el `Counter` porque el `Counter` permanece en la misma posici√≥n**.

**Es el mismo componente en la misma posici√≥n, por lo tanto desde la perspectiva de React, es el mismo contador**.


#### A React le importa es la posici√≥n del componente en el arbol de componentes, no el marcado HTML/JSX

¬°Recuerda que **es la posici√≥n en el √°rbol de la UI ‚Äîno en el markup JSX‚Äî lo que le importa a React!** Este componente tiene dos cl√°usulas `return` con diferentes etiquetas JSX `<Counter />` dentro y fuera del `if`:

**App.jsx**
```jsx
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  if (isFancy) {
    return ( // üëà
      <div>
        <Counter isFancy={true} /> // üëà
        <label>
          <input
            type="checkbox"
            checked={isFancy}
            onChange={e => {
              setIsFancy(e.target.checked)
            }}
          />
          Usar un estilo elegante
        </label>
      </div>
    );
  }
  return ( // üëà
    <div>
      <Counter isFancy={false} /> // üëà
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Usar un estilo elegante
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```
Se podr√≠a esperar que el estado se reiniciara al marcar la casilla de verificaci√≥n, pero no es as√≠. Esto se debe a que **las dos etiquetas `<Counter />` se renderizan en la misma posici√≥n.** React no sabe d√≥nde colocas las condiciones en tu funci√≥n. Todo lo que ¬´ve¬ª es el √°rbol que devuelves. En ambos casos, el componente `App` devuelve un `<div>` con `<Counter />` como primer hijo. Por eso React los considera como _el mismo_ `<Counter />`.

Puedes pensar que tienen la misma ¬´direcci√≥n¬ª: el primer hijo del primer hijo de la ra√≠z. As√≠ es como React los hace coincidir entre los renderizados anteriores y los siguientes, independientemente de c√≥mo estructures tu l√≥gica.

## ‚≠ê Diferentes componentes en la misma posici√≥n reinician el estado

En este ejemplo, al marcar la casilla de verificaci√≥n se sustituir√° `<Counter>` por un `<p>`:

**App.js**
```jsx
import { useState } from 'react';

export default function App() {
  const [isPaused, setIsPaused] = useState(false);
  return (
    <div>
      {isPaused ? ( // üëà
        <p>¬°Nos vemos luego!</p> // üëà
      ) : (
        <Counter />  // üëà
      )}
      <label>
        <input
          type="checkbox"
          checked={isPaused}
          onChange={e => {
            setIsPaused(e.target.checked)
          }}
        />
        T√≥mate un descanso
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```

Muestra:

![[4-perservar-y-reiniciar-el-estado-14.png]]

Al pulsar el boton muestra:

![[4-perservar-y-reiniciar-el-estado-15.png]]

Al pulsar la casilla muestra:

![[4-perservar-y-reiniciar-el-estado-16.png]]

Al volver a pulsar en la casilla vemos como el estado se ha reiniciado:

![[4-perservar-y-reiniciar-el-estado-14.png]]

Aqu√≠ se cambia entre _diferentes_ tipos de componentes en la misma posici√≥n. Inicialmente, el primer hijo del `<div>` conten√≠a un `Counter`. Pero cuando lo cambiaste por un `p`, React elimin√≥ el `Counter` del √°rbol de la UI y destruy√≥ su estado.

![[4-perservar-y-reiniciar-el-estado-17.webp|660]]

Cuando `Counter` cambia a `p`, se borra el `Counter` y se a√±ade `p`

![[4-perservar-y-reiniciar-el-estado-18.webp]]

Al volver a cambiar, se borra `p` y se a√±ade el `Counter`.

Adem√°s, **cuando se renderiza un componente diferente en la misma posici√≥n, se reinicia el estado de todo su sub√°rbol.** Para ver c√≥mo funciona, incrementa el contador y luego marca la casilla:

**App.js**
```jsx
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <div> // üëà
          <Counter isFancy={true} />  // üëà
        </div>
      ) : (
        <section> // üëà
          <Counter isFancy={false} /> // üëà
        </section>
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Usar un estilo elegante
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```

Muestra: 

![[4-perservar-y-reiniciar-el-estado-18.png]]

Agregando uno al pulsar el bot√≥n:

![[4-perservar-y-reiniciar-el-estado-19.png]]

Pulsando en la casilla, vemos como se reinicia el estado:

![[4-perservar-y-reiniciar-el-estado-20.png]]

El estado del contador se reinicia cuando se hace clic en la casilla de verificaci√≥n. **Aunque se renderiza un `Counter`, el primer hijo del `div` cambia de `div` a `section`. Cuando el `div` hijo se elimin√≥ del DOM, todo el √°rbol debajo de √©l (incluyendo el `Counter` y su estado) se destruy√≥ tambi√©n**.

![[4-perservar-y-reiniciar-el-estado-21.webp]]

Cuando `section` cambia a `div`, se elimina la `section` y se a√±ade el nuevo `div`

![[4-perservar-y-reiniciar-el-estado-22.webp]]

Al volver a cambiar, se elimina el `div` y se a√±ade la nueva `section`.

Como regla general, **si quieres preservar el estado entre rerenderizados, la estructura de tu √°rbol necesita ¬´coincidir¬ª de un render a otro. Si la estructura es diferente, el estado se destruye porque React destruye el estado cuando elimina un componente del √°rbol**.

#### Por ello no se deben definir componentes anidados

Es por este motivo que no se deben anidar las definiciones de las funciones de los componentes.

Aqu√≠, la funci√≥n del componente `MyTextField` se define _dentro_ de `MyComponent`:

**App.js**
```jsx
import { useState } from 'react';

export default function MyComponent() { // üëà
  const [counter, setCounter] = useState(0);

  function MyTextField() { // üëà
    const [text, setText] = useState('');

    return (
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
    );
  }

  return (
    <>
      <MyTextField />
      <button onClick={() => {
        setCounter(counter + 1)
      }}>Hiciste clic {counter} veces</button>
    </>
  );
}
```

Muestra:

![[4-perservar-y-reiniciar-el-estado-22.png]]

Escribiendo en el input:

![[4-perservar-y-reiniciar-el-estado-23.png]]

Haciendo clic en el bot√≥n, vemos c√≥mo desaparece el input:

![[4-perservar-y-reiniciar-el-estado-24.png]]

**Cada vez que se hace clic en el bot√≥n, el estado de la entrada desaparece. Esto se debe a que se crea una funci√≥n _diferente_ de `MyTextField` para cada renderizado de `MyComponent`. Est√°s renderizando un componente _diferente_ en la misma posici√≥n, por lo que React reinicia todo el estado que est√© anidado por debajo**. Esto conlleva a errores y problemas de rendimiento. Para evitar este problema, **declara siempre las funciones del componente en el nivel superior, y no anides sus definiciones.**

## ‚≠ê Reiniciar el estado en la misma posici√≥n

**Por defecto, React preserva el estado de un componente mientras permanece en la misma posici√≥n**. Normalmente, esto es exactamente lo que quieres, as√≠ que tiene sentido como comportamiento por defecto. Pero a veces, **es posible que quieras reiniciar el estado de un componente**. Considera esta aplicaci√≥n que permite a dos jugadores llevar la cuenta de sus puntuaciones durante cada turno:

**App.js**
```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter person="Taylor" />
      ) : (
        <Counter person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        ¬°Siguiente jugador!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>Puntos de {person}: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```

Muestra:

![[4-perservar-y-reiniciar-el-estado-25.png]]

Agrega uno al jugador Taylor:

![[4-perservar-y-reiniciar-el-estado-26.png]]

Damos click al bot√≥n para ir al siguiente jugador, vemos c√≥mo los puntos del anterior jugador se mantienen:

![[4-perservar-y-reiniciar-el-estado-27.png]]

Actualmente, cuando se cambia de jugador, la puntuaci√≥n se conserva. **Los dos `Counter` aparecen en la misma posici√≥n, por lo que React los ve como _el mismo_ `Counter` cuya prop `person` ha cambiado**.

Pero conceptualmente, en esta aplicaci√≥n deber√≠an ser dos contadores separados. Podr√≠an aparecer en el mismo lugar en la UI, pero uno es un contador para Taylor, y otro es un contador para Sarah.

Hay dos maneras de reiniciar el estado al cambiar entre ellos:

1. Renderizar los componentes en diferentes posiciones
2. Dar a cada componente una identidad expl√≠cita con¬†`key`.

### Opci√≥n 1: Renderizar un componente en diferentes posiciones

Si quieres que estos dos `Counter` sean independientes, **puedes representarlos en dos posiciones diferentes**:

**App.js**
```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA && // üëà
        <Counter person="Taylor" /> // üëà
      }
      {!isPlayerA && // üëà
        <Counter person="Sarah" /> // üëà
      }
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        ¬°Siguiente jugador!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>Puntos de {person}: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}
```

- Inicialmente,¬†`isPlayerA`¬†es¬†`true`. As√≠ que la primera posici√≥n contiene el estado¬†`Counter`, y la segunda est√° vac√≠a.
- Cuando haces clic en el bot√≥n ¬´Siguiente jugador¬ª, la primera posici√≥n se borra, pero la segunda contiene ahora un ‚ÄòCounter‚Äô.

![[4-perservar-y-reiniciar-el-estado-28.png|680]]


Muestra:

![[4-perservar-y-reiniciar-el-estado-25.png]]

Agrega uno al jugador Taylor:

![[4-perservar-y-reiniciar-el-estado-26.png]]

Ahora al ir al siguiente jugador, vemos que el estado del contador se reinicia, y no concerva el punto del anterior jugador:

![[4-perservar-y-reiniciar-el-estado-29.png]]

El estado de cada `Counter` se destruye cada vez que se elimina del DOM. Por eso se reinician cada vez que se hace clic en el bot√≥n.

**Esta soluci√≥n es conveniente cuando s√≥lo tienes unos pocos componentes independientes renderizados en el mismo lugar. En este ejemplo, s√≥lo tienes dos, por lo que no es una molestia renderizar ambos por separado en el JSX**.

### üåü Option 2: Opci√≥n 2: Reiniciar el estado con una¬†_key_

Tambi√©n hay otra forma, m√°s gen√©rica, de reiniciar el estado de un componente.

Es posible que hayas visto _`key`_ al [renderizar listas.](https://es.react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) **Las _keys_ no son s√≥lo para las listas. Puedes usar _keys_ para que React distinga entre cualquier componente**. Por defecto, React utiliza el orden dentro del padre (¬´primer contador¬ª, ¬´segundo contador¬ª) para discernir entre los componentes. Pero **las _keys_ te permiten decirle a React que no es s√≥lo un _primer_ contador, o un _segundo_ contador, sino un contador espec√≠fico**; por ejemplo, el contador de _Taylor_. De esta manera, React conocer√° el contador de _Taylor_ dondequiera que aparezca en el √°rbol!

En este ejemplo, los dos `<Counter />` no comparten estado aunque aparezcan en el mismo lugar en JSX:

**App.js**
```jsx
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key="Taylor" person="Taylor" /> // üëà
      ) : (
        <Counter key="Sarah" person="Sarah" /> // üëà
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        ¬°Siguiente jugador!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>Puntos de {person}: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Agregar uno
      </button>
    </div>
  );
}

```

El cambio entre Taylor y Sarah no preserva el estado. Esto se debe a que **le asignaste diferentes _`keys`_:**

```jsx
{isPlayerA ? (
  <Counter key="Taylor" person="Taylor" />
) : (
  <Counter key="Sarah" person="Sarah" />
)}
```

**Especificar una _`key`_ le dice a React que use la propia _`key`_ como parte de la posici√≥n, en lugar de su orden dentro del padre. Por eso, aunque los renderices en el mismo lugar en JSX, desde la perspectiva de React, son dos contadores diferentes. Como resultado, nunca compartir√°n estado**. Cada vez que un contador aparece en la pantalla, su estado se crea. Cada vez que se elimina, su estado se destruye. Alternar entre ellos reinicia su estado una y otra vez.

> [!note]
> Recuerda que las _keys_ no son √∫nicas globalmente. S√≥lo especifican la posici√≥n _dentro del padre_.

### ‚≠ê Reiniciar un formulario con una¬†_key_

Reiniciar el estado con una _key_ es especialmente √∫til cuando se trata de formularios.

En esta aplicaci√≥n de chat, el componente `<Chat>` contiene el estado del cuadro de texto:

**App.js**
```jsx
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat contact={to} />
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```

**ContactList.js**
```jsx
export default function ContactList({
  selectedContact,
  contacts,
  onSelect
}) {
  return (
    <section className="contact-list">
      <ul>
        {contacts.map(contact =>
          <li key={contact.id}> // üëà
            <button onClick={() => {
              onSelect(contact);
            }}>
              {contact.name}
            </button>
          </li>
        )}
      </ul>
    </section>
  );
}
```

**Chat.js**
```jsx
import { useState } from 'react';

export default function Chat({ contact }) {
  const [text, setText] = useState('');
  return (
    <section className="chat">
      <textarea
        value={text}
        placeholder={'Chatear con ' + contact.name}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button>Enviar a {contact.email}</button>
    </section>
  );
}
```

Muestra:

![[4-perservar-y-reiniciar-el-estado-30.png]]

Escribimos algo en el input:

![[4-perservar-y-reiniciar-el-estado-31.png]]

Al cambiar a otro cont√°cto, vemos c√≥mo el texto permanece, cosa que no queremos:

![[4-perservar-y-reiniciar-el-estado-32.png]]

Prueba a introducir algo en el cuadro de texto y luego pulsa ¬´Alice¬ª o ¬´Bob¬ª para elegir un destinatario diferente. Notar√°s que **el estado del cuadro de texto se conserva porque el `<Chat>` se renderiza en la misma posici√≥n en el √°rbol.**

**En muchas aplicaciones, este puede ser el comportamiento deseado, pero no en una aplicaci√≥n de chat!**. No quieres que el usuario env√≠e un mensaje que ya ha escrito a una persona equivocada debido a un clic accidental. Para solucionarlo, a√±ade una `key`:

```jsx
<Chat key={to.id} contact={to} />
```

**Esto asegura que cuando selecciones un destinatario diferente, el componente `Chat` se recrear√° desde cero**, incluyendo cualquier estado en el √°rbol que est√© por debajo. React tambi√©n recrear√° los elementos del DOM en lugar de reutilizarlos.

Ahora al cambiar de destinatario siempre se borra el campo de texto:

**App.jsx**
```jsx
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat key={to.id} contact={to} />  // üëà
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```
#### Preservar el estado de los componentes removidos

En una aplicaci√≥n de chat real, probablemente querr√°s recuperar el estado de la entrada cuando el usuario vuelva a seleccionar el destinatario anterior. Hay algunas maneras de mantener el estado ¬´vivo¬ª para un componente que ya no es visible:

- Podr√≠as mostrar¬†_todos_¬†los chats en lugar de s√≥lo el actual, pero ocultar todos los dem√°s con CSS. Los chats no se eliminar√≠an del √°rbol, por lo que su estado local se conservar√≠a. Esta soluci√≥n funciona muy bien para UIs simples. Pero puede ser muy lenta si los √°rboles ocultos son grandes y contienen muchos nodos DOM.
- Podr√≠as¬†[subir el estado](https://es.react.dev/learn/sharing-state-between-components)¬†y mantener el mensaje pendiente para cada destinatario en el componente padre. De esta manera, cuando los componentes hijos se eliminan, no importa, porque es el padre el que mantiene la informaci√≥n importante. Esta es la soluci√≥n m√°s com√∫n. Tambi√©n podr√≠as utilizar una fuente diferente adem√°s del estado de React. Por ejemplo, probablemente quieras que el borrador de un mensaje persista incluso si el usuario cierra accidentalmente la p√°gina. Para implementar esto, podr√≠as hacer que el componente¬†`Chat`¬†inicialice su estado leyendo de¬†[`localStorage`](https://developer.mozilla.org/es/docs/Web/API/Window/localStorage)¬†y guardar los borradores all√≠ tambi√©n.

Independientemente de la estrategia que elijas, un chat _con Alice_ es conceptualmente distinto de un chat _con Bob_, por lo que tiene sentido dar una _`key`_ al √°rbol `<Chat>` basado en el destinatario actual.

## ‚≠ê Recapitulaci√≥n

- React mantiene el estado mientras el mismo componente se renderice en la misma posici√≥n.
- El estado no se mantiene en las etiquetas JSX. Se asocia a la posici√≥n del √°rbol en la que se coloca ese JSX.
- Puedes forzar a un sub√°rbol a reiniciar su estado d√°ndole una¬†_key_¬†diferente.
- No anides las definiciones de los componentes, o reiniciar√°s el estado por accidente.