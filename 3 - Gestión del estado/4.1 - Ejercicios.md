## DesafÃ­oÂ 1Â deÂ 5:Â Corregir la desapariciÃ³n del texto de entrada

Este ejemplo muestra un mensaje cuando se pulsa el botÃ³n. Sin embargo, al pulsar el botÃ³n tambiÃ©n se reinicia accidentalmente la entrada. Â¿Por quÃ© ocurre esto? ArrÃ©glalo para que al pulsar el botÃ³n no se reinicie el texto de entrada.

```jsx
import { useState } from 'react';

export default function App() {
  const [showHint, setShowHint] = useState(false);
  if (showHint) {
    return (
      <div>
        <p><i>Pista: Â¿Tu ciudad favorita?</i></p>
        <Form />
        <button onClick={() => {
          setShowHint(false);
        }}>Ocultar pista</button>
      </div>
    );
  }
  return (
    <div>
      <Form />
      <button onClick={() => {
        setShowHint(true);
      }}>Mostrar pista</button>
    </div>
  );
}

function Form() {
  const [text, setText] = useState('');
  return (
    <textarea
      value={text}
      onChange={e => setText(e.target.value)}
    />
  );
}
```

Muestra: 

![[4.1-perservar-y-reiniciar-el-estado-1.png]]

Al pulsar el botÃ³n muestra:

![[4.1-perservar-y-reiniciar-el-estado-2.png]]

### Respuesta

El problema es que `Form` se renderiza en diferentes posiciones. En la rama `if`, es el segundo hijo del `<div>`, pero en la rama `else`, es el primer hijo. Por lo tanto, el tipo de componente en cada posiciÃ³n cambia. La primera posiciÃ³n cambia entre tener un `p` y un `Form`, mientras que la segunda posiciÃ³n cambia entre tener un `Form` y un `button`. React reinicia el estado cada vez que cambia el tipo de componente.

La soluciÃ³n mÃ¡s sencilla es unificar las ramas para que `Form` se renderice siempre en la misma posiciÃ³n:

```jsx
import { useState } from "react";

export default function App() {
  const [showHint, setShowHint] = useState(false);
  return ( // ğŸ‘ˆ
    <div>
      {showHint && ( // ğŸ‘ˆ
        <p>
          <i>Pista: Â¿Tu ciudad favorita?</i>
        </p>
      )}
      <Form />
      <button
        onClick={() => {
          setShowHint(!showHint); // ğŸ‘ˆ
        }}
      >
        Ocultar pista
      </button>
    </div>
  );
}

function Form() {
  const [text, setText] = useState("");
  return <textarea value={text} onChange={(e) => setText(e.target.value)} />;
}
```

## â­ DesafÃ­oÂ 2Â deÂ 5:Â Intercambiar dos campos de formulario

Este formulario permite introducir el nombre y los apellidos. TambiÃ©n tiene una casilla de verificaciÃ³n que controla quÃ© campo va primero. Si marca la casilla, el campo Â«ApellidoÂ» aparecerÃ¡ antes que el campo Â«NombreÂ».

Casi funciona, pero hay un error. Si rellenas la entrada Â«NombreÂ» y marcas la casilla, el texto se queda en la primera entrada (que ahora es Â«ApellidoÂ»). ArrÃ©glalo para que el texto de la entrada _tambiÃ©n_ se mueva cuando inviertas el orden.

**App.jsx**
```jsx
import { useState } from 'react';

export default function App() {
  const [reverse, setReverse] = useState(false);
  let checkbox = (
    <label>
      <input
        type="checkbox"
        checked={reverse}
        onChange={e => setReverse(e.target.checked)}
      />
      Invertir el orden
    </label>
  );
  if (reverse) {
    return (
      <>
        <Field label="Apellido" /> 
        <Field label="Nombre" />
        {checkbox}
      </>
    );
  } else {
    return (
      <>
        <Field label="Nombre" /> 
        <Field label="Apellido" />
        {checkbox}
      </>
    );    
  }
}

function Field({ label }) {
  const [text, setText] = useState('');
  return (
    <label>
      {label}:{' '}
      <input
        type="text"
        value={text}
        placeholder={label}
        onChange={e => setText(e.target.value)}
      />
    </label>
  );
}
```

Muestra: 

![[4.1-perservar-y-reiniciar-el-estado-3.png]]

Al hacer click en la casilla: 

![[4.1-perservar-y-reiniciar-el-estado-4.png]]

### Respuesta

Da una _`key`_ a ambos componentes `<Field>` en ambas ramas `if` y `else`. Esto le dice a React cÃ³mo Â«emparejarÂ» el estado correcto para cualquiera de los dos `<Field>` incluso si su orden dentro del padre cambia:

**App.jsx**
```jsx
import { useState } from "react";

export default function App() {
  const [reverse, setReverse] = useState(false);
  let checkbox = (
    <label>
      <input
        type="checkbox"
        checked={reverse}
        onChange={(e) => setReverse(e.target.checked)}
      />
      Invertir el orden
    </label>
  );
  if (reverse) {
    return (
      <>
        <Field key="lastname" label="Apellido" /> // ğŸ‘ˆ
        <Field key="name" label="Nombre" /> // ğŸ‘ˆ
        {checkbox}
      </>
    );
  } else {
    return (
      <>
        <Field key="name" label="Nombre" /> // ğŸ‘ˆ
        <Field key="lastname" label="Apellido" /> // ğŸ‘ˆ
        {checkbox}
      </>
    );
  }
}

function Field({ label }) {
  const [text, setText] = useState("");
  return (
    <label>
      {label}:{" "}
      <input
        type="text"
        value={text}
        placeholder={label}
        onChange={(e) => setText(e.target.value)}
      />
    </label>
  );
}
```
> [!important]
> El estado de ambos componente se mantiene al cambiar el orden porque al hacerlo, ambos componentes siguen existiendo cuando cambian de lugar, pero si en un condicional hacemos que ya no aparezca uno de los componentes, entonces su estado sÃ­ cambiarÃ¡ cuando volvamos al otro condicional, esto porque el componente ya habrÃ¡ desaparecido del arbol. 
> 
> Por ejemplo, si eliminamos el componente con la `key="lastname"` cuando la casilla estÃ© marcada, entonces cuando volvamos a pulsar en la casilla el componente aparecerÃ¡ pero con el estado reiniciado:
> 
>```jsx
>// ...
>if (reverse) {
 >   return (
 >     <>
 >       {/* <Field key="lastname" label="Apellido" /> */} // ğŸ‘ˆ
 >       <Field key="name" label="Nombre" />
 >       {checkbox}
 >     </>
 >   );
 > } else {
 >   return (
 >     <>
 >       <Field key="name" label="Nombre" />
 >       <Field key="lastname" label="Apellido" />
 >       {checkbox}
 >     </>
 >   );
 > }
 > // ...
>```
> 
> Muestra: 
>
>![[4.1-perservar-y-reiniciar-el-estado-3.png]]
> 
> Al pulsar en la casilla muestra:
> 
> ![[4.1-perservar-y-reiniciar-el-estado-5.png]]
> 
> Al volver a pulsarla muestra (el estado del input del apellido ha desaparecido):
> 
> ![[4.1-perservar-y-reiniciar-el-estado-6.png]]

## â­ DesafÃ­oÂ 3Â deÂ 5:Â Reiniciar un formulario detallado

Esta es una lista de contactos editable. Puedes editar los datos del contacto seleccionado y luego pulsar Â«GuardarÂ» para actualizarlo, o Â«ReiniciarÂ» para deshacer los cambios.

Cuando seleccionas un contacto diferente (por ejemplo, Alicia), el estado se actualiza pero el formulario sigue mostrando los detalles del contacto anterior. ArrÃ©glalo para que el formulario se reinicie cuando cambie el contacto seleccionado.

**App.jsx**
```jsx
import { useState } from 'react';
import ContactList from './ContactList.js';
import EditContact from './EditContact.js';

export default function ContactManager() {
  const [
    contacts,
    setContacts
  ] = useState(initialContacts);
  const [
    selectedId,
    setSelectedId
  ] = useState(0);
  const selectedContact = contacts.find(c =>
    c.id === selectedId
  );

  function handleSave(updatedData) {
    const nextContacts = contacts.map(c => {
      if (c.id === updatedData.id) {
        return updatedData;
      } else {
        return c;
      }
    });
    setContacts(nextContacts);
  }

  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={selectedId}
        onSelect={id => setSelectedId(id)}
      />
      <hr />
      <EditContact
        initialData={selectedContact}
        onSave={handleSave}
      />
    </div>
  )
}

const initialContacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```

Muestra:

![[4.1-perservar-y-reiniciar-el-estado-7.png]]

Al pulsar sobre otro nombre, se mantiene los datos de la anterior persona:

![[4.1-perservar-y-reiniciar-el-estado-9.png]]

### Respuesta

Proporciona una `key={selectedId}` al componente `EditContact`. De esta manera, al cambiar entre diferentes contactos se reiniciarÃ¡ el formulario:

**App.jsx**
```jsx
import { useState } from 'react';
import ContactList from './ContactList.js';
import EditContact from './EditContact.js';

export default function ContactManager() {
  const [
    contacts,
    setContacts
  ] = useState(initialContacts);
  const [
    selectedId,
    setSelectedId
  ] = useState(0);
  const selectedContact = contacts.find(c =>
    c.id === selectedId
  );

  function handleSave(updatedData) {
    const nextContacts = contacts.map(c => {
      if (c.id === updatedData.id) {
        return updatedData;
      } else {
        return c;
      }
    });
    setContacts(nextContacts);
  }

  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={selectedId}
        onSelect={id => setSelectedId(id)}
      />
      <hr />
      <EditContact
        key={selectedId} // ğŸ‘ˆ
        initialData={selectedContact}
        onSave={handleSave}
      />
    </div>
  )
}

const initialContacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```

## DesafÃ­oÂ 4Â deÂ 5:Â Borrar una imagen mientras se cargaÂ 

Al pulsar Â«SiguienteÂ», el navegador comienza a cargar la siguiente imagen. Sin embargo, como se muestra en la misma etiqueta `<img>`, por defecto se seguirÃ­a viendo la imagen anterior hasta que se cargue la siguiente. Esto puede ser indeseable si es importante que el texto coincida siempre con la imagen. CÃ¡mbialo para que en el momento en que pulses Â«SiguienteÂ», la imagen anterior se borre inmediatamente.

**App.jsx**
```jsx
import { useState } from 'react';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const hasNext = index < images.length - 1;

  function handleClick() {
    if (hasNext) {
      setIndex(index + 1);
    } else {
      setIndex(0);
    }
  }

  let image = images[index];
  return (
    <>
      <button onClick={handleClick}>
        Siguiente
      </button>
      <h3>
        Imagen {index + 1} de {images.length}
      </h3>
      <img src={image.src} />
      <p>
        {image.place}
      </p>
    </>
  );
}

let images = [{
  place: 'Penang, Malasia',
  src: 'https://i.imgur.com/FJeJR8M.jpg'
}, {
  place: 'Lisboa, Portugal',
  src: 'https://i.imgur.com/dB2LRbj.jpg'
}, {
  place: 'Bilbao, EspaÃ±a',
  src: 'https://i.imgur.com/z08o2TS.jpg'
}, {
  place: 'ValparaÃ­so, Chile',
  src: 'https://i.imgur.com/Y3utgTi.jpg'
}, {
  place: 'Schwyz, Suiza',
  src: 'https://i.imgur.com/JBbMpWY.jpg'
}, {
  place: 'Praga, Chequia',
  src: 'https://i.imgur.com/QwUKKmF.jpg'
}, {
  place: 'Liubliana, Eslovenia',
  src: 'https://i.imgur.com/3aIiwfm.jpg'
}];
```

Muestra:

![[4.1-perservar-y-reiniciar-el-estado-8.png]]

Puede proporcionar una _`key`_ a la etiqueta `<img>`. Cuando esa _`key`_ cambie, React volverÃ¡ a crear el nodo DOM `<img>` desde cero. Esto provoca un breve destello cuando se carga cada imagen, por lo que no es algo que quieras hacer para cada imagen de tu aplicaciÃ³n. Pero tiene sentido si quieres asegurarte de que la imagen siempre coincide con el texto.

**App.jsx**
```jsx
import { useState } from 'react';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const hasNext = index < images.length - 1;

  function handleClick() {
    if (hasNext) {
      setIndex(index + 1);
    } else {
      setIndex(0);
    }
  }

  let image = images[index];
  return (
    <>
      <button onClick={handleClick}>
        Siguiente
      </button>
      <h3>
        Imagen {index + 1} de {images.length}
      </h3>
      <img key={image.src} src={image.src} /> // ğŸ‘ˆ
      <p>
        {image.place}
      </p>
    </>
  );
}

let images = [{
  place: 'Penang, Malasia',
  src: 'https://i.imgur.com/FJeJR8M.jpg'
}, {
  place: 'Lisboa, Portugal',
  src: 'https://i.imgur.com/dB2LRbj.jpg'
}, {
  place: 'Bilbao, EspaÃ±a',
  src: 'https://i.imgur.com/z08o2TS.jpg'
}, {
  place: 'ValparaÃ­so, Chile',
  src: 'https://i.imgur.com/Y3utgTi.jpg'
}, {
  place: 'Schwyz, Suiza',
  src: 'https://i.imgur.com/JBbMpWY.jpg'
}, {
  place: 'Praga, Chequia',
  src: 'https://i.imgur.com/QwUKKmF.jpg'
}, {
  place: 'Liubliana, Eslovenia',
  src: 'https://i.imgur.com/3aIiwfm.jpg'
}];
```

## â­ DesafÃ­oÂ 5Â deÂ 5:Â Arreglar un estado mal colocado en la lista

En esta lista, cada `Contact` tiene un estado que determina si se ha pulsado Â«Mostrar correo electrÃ³nicoÂ» para Ã©l. Pulsa Â«Mostrar correo electrÃ³nicoÂ» para Alice, y luego marca la casilla Â«Mostrar en orden inversoÂ». NotarÃ¡s que ahora es el correo electrÃ³nico de _Taylor_ el que estÃ¡ expandido, pero el de Alice â€”que se ha movido a la parte inferiorâ€” aparece colapsado.

ArrÃ©glalo para que el estado expandido se asocie a cada contacto, independientemente del orden elegido.

**App.jsx**
```jsx
import { useState } from 'react';
import Contact from './Contact.js';

export default function ContactList() {
  const [reverse, setReverse] = useState(false);

  const displayedContacts = [...contacts];
  if (reverse) {
    displayedContacts.reverse();
  }

  return (
    <>
      <label>
        <input
          type="checkbox"
          value={reverse}
          onChange={e => {
            setReverse(e.target.checked)
          }}
        />{' '}
        Mostrar en orden inverso
      </label>
      <ul>
        {displayedContacts.map((contact, i) =>
          <li key={i}>
            <Contact contact={contact} />
          </li>
        )}
      </ul>
    </>
  );
}

const contacts = [
  { id: 0, name: 'Alice', email: 'alice@mail.com' },
  { id: 1, name: 'Bob', email: 'bob@mail.com' },
  { id: 2, name: 'Taylor', email: 'taylor@mail.com' }
];
```

Muestra:

![[4.1-perservar-y-reiniciar-el-estado-10.png]]

Al marcar la casilla:

![[4.1-perservar-y-reiniciar-el-estado-11.png]]

### Respuesta

El problema es que este ejemplo utilizaba el Ã­ndice como `key`:

```jsx
// ...
{displayedContacts.map((contact, i) =>
  <li key={i}>
  // ...
```

Sin embargo, queremos que el estado se asocie a _cada contacto en particular_.

Si se utiliza el ID del contacto como _`key`_ se soluciona el problema:

**App.jsx**
```jsx
import { useState } from 'react';
import Contact from './Contact.js';

export default function ContactList() {
  const [reverse, setReverse] = useState(false);

  const displayedContacts = [...contacts];
  if (reverse) {
    displayedContacts.reverse();
  }

  return (
    <>
      <label>
        <input
          type="checkbox"
          value={reverse}
          onChange={e => {
            setReverse(e.target.checked)
          }}
        />{' '}
        Mostrar en orden inverso
      </label>
      <ul>
        {displayedContacts.map((contact) => // ğŸ‘ˆ
          <li key={contact.id}> // ğŸ‘ˆ
            <Contact contact={contact} />
          </li>
        )}
      </ul>
    </>
  );
}

const contacts = [
  { id: 0, name: 'Alice', email: 'alice@mail.com' },
  { id: 1, name: 'Bob', email: 'bob@mail.com' },
  { id: 2, name: 'Taylor', email: 'taylor@mail.com' }
];
```