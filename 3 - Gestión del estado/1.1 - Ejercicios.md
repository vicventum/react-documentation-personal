## DesafÃ­oÂ 1Â deÂ 3:Â AÃ±ade y elimina una clase de CSS

Haz que al hacer clic en la imagen _elimine_ la clase CSS `background--active` del `<div>` externo, pero _agregue_ la clase `picture--active` a la `<img>`. Al hacer clic en el fondo nuevamente, deberÃ­a restaurar las clases CSS originales.

Visualmente, deberÃ­as esperar que al hacer clic en la imagen se elimine el fondo morado y se resalte el borde de la imagen. Al hacer clic fuera de la imagen, se resalta el fondo, pero se elimina el resaltado del borde de la imagen.

**App.jsx**
```jsx
export default function Picture() {
  return (
    <div className="background background--active">
      <img
        className="picture"
        alt="Casas de arcoiris en Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
      />
    </div>
  );
}
```

Muestra:

![[1.1-reaccionar-a-las-entradas-con-el-estado-1.png]]

### Respuesta

Este componente tiene dos estados visuales: cuando la imagen estÃ¡ activa y cuando la imagen estÃ¡ inactiva:

- Cuando la imagen estÃ¡ activa, las clases CSS sonÂ `background`Â yÂ `picture picture--active`.
- Cuando la imagen estÃ¡ inactiva, las clases CSS sonÂ `background background--active`Â yÂ `picture`.

Una sola variable de estado booleana es suficiente para recordar si la imagen estÃ¡ activa. La tarea original era eliminar o agregar clases CSS. Sin embargo, en React, necesitas _describir_ lo que deseas ver en lugar de _manipular_ los elementos de la interfaz de usuario. Por lo tanto, debes calcular ambas clases CSS en funciÃ³n del estado actual. TambiÃ©n debes [detener la propagaciÃ³n](https://es.react.dev/learn/responding-to-events#stopping-propagation) para que al hacer clic en la imagen no se registre como un clic en el fondo.

**App.jsx**
```jsx
import { useState } from "react";

export default function Picture() {
  const [isPictureActive, setIsPictureActive] = useState(false);

  let backgroundClass = "background"; // ğŸ‘ˆ
  let pictureClass = "picture"; // ğŸ‘ˆ
  if (isPictureActive) pictureClass += " picture--active"; // ğŸ‘ˆ
  else backgroundClass += " background--active"; // ğŸ‘ˆ

  function handleBackground() { // ğŸ‘ˆ
    setIsPictureActive(false);
  }
  function handlePicture(e) { // ğŸ‘ˆ
    e.stopPropagation();
    setIsPictureActive(true);
  }

  return (
    <div className={backgroundClass} onClick={handleBackground}>
      <img
        className={pictureClass}
        alt="Casas de arcoiris en Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
        onClick={handlePicture}
      />
    </div>
  );
}
```

Muestra:

![[1.1-reaccionar-a-las-entradas-con-el-estado-1.png]]

Al hacer click en el fondo:

![[1.1-reaccionar-a-las-entradas-con-el-estado-2.png]]


## DesafÃ­oÂ 2Â deÂ 3:Â Editor de perfil

Este formulario cambia entre dos modos: en el modo de ediciÃ³n, ves los formularios de entrada y en el modo de visualizaciÃ³n, solo ves los resultados. La etiqueta del botÃ³n cambia entre Â«EditarÂ» y Â«GuardarÂ» en dependencia del modo en que estÃ©s. Cuando cambias las entradas, el mensaje de bienvenida de la parte inferior se actualiza en tiempo real.

Tu tarea es reimplementarlo en React en el _sandbox_ de abajo. Para tu conveniencia, el marcado ya ha sido convertido a JSX, pero tendrÃ¡s que hacer que muestre y oculte las entradas como hace el original.

Â¡AsegÃºrate de que tambiÃ©n actualice el texto de la parte inferior!

**App.jsx**
```jsx
export default function EditProfile() {
  return (
    <form>
      <label>
        Nombre:{' '}
        <b>Jane</b>
        <input />
      </label>
      <label>
        Apellido:{' '}
        <b>Jacobs</b>
        <input />
      </label>
      <button type="submit">
        Editar Perfil
      </button>
      <p><i>Â¡Hola, Jane Jacobs!</i></p>
    </form>
  );
}
```
Muestra: 

![[1.1-reaccionar-a-las-entradas-con-el-estado-3.png]]

El comportamiento esperado es que muestre:

![[1.1-reaccionar-a-las-entradas-con-el-estado-4.png]]

y al hacer click en el botÃ³n muestre:

![[1.1-reaccionar-a-las-entradas-con-el-estado-5.png]]

### Respuesta

NecesitarÃ¡s dos variables de estado para guardar los valores de las entradas: `firstName` y `lastName`. TambiÃ©n necesitarÃ¡s una variable de estado `isEditing` que guarde si se debe mostrar las entradas o no. No deberÃ­as necesitar una variable `fullName` porque el nombre completo siempre se puede calcular a partir de `firstName` y `lastName`.

Finalmente, deberÃ­as utilizar [renderizado condicional](https://es.react.dev/learn/conditional-rendering) para mostrar o esconder las entradas en dependencia del valor de `isEditing`.

**App.jsx**
```jsx
import { useState } from "react";

export default function EditProfile() {
  const [name, setName] = useState("Jane"); // ğŸ‘ˆ
  const [lastname, setLastname] = useState("Jacobs"); // ğŸ‘ˆ
  const [isEdit, setIsEdit] = useState(false); // ğŸ‘ˆ

  function handleSubmit(e) { // ğŸ‘ˆ
    e.preventDefault();
    setIsEdit(!isEdit);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Nombre:{" "}
        {isEdit ? ( // ğŸ‘ˆ
          <input
            value={name} // ğŸ‘ˆ
            onChange={(event) => setName(event.target.value)} // ğŸ‘ˆ
          />
        ) : (
          <b>{name}</b>
        )}
      </label>
      <label>
        Apellido:{" "}
        {isEdit ? ( // ğŸ‘ˆ
          <input
            value={lastname} // ğŸ‘ˆ
            onChange={() => // ğŸ‘ˆ
              setLastname((event) => setLastname(event.target.value))
            }
          />
        ) : (
          <b>{lastname}</b>
        )}
      </label>
      <button type="submit">
        {isEdit ? "Guardar Perfil" : "Editar Perfil"} // ğŸ‘ˆ
      </button>
      <p>
        <i>
          Â¡Hola, {name} {lastname}! // ğŸ‘ˆ
        </i>
      </p>
    </form>
  );
}
```