## DesafÃ­oÂ 1Â deÂ 4:Â Corregir una variable que no se actualiza`

Este componente `Timer` mantiene una variable de estado `count` que se incrementa cada segundo. El valor por el que se incrementa se almacena en la variable de estado `increment`. Puedes controlar la variable `increment` con los botones mÃ¡s y menos.

Sin embargo, no importa cuÃ¡ntas veces haga clic en el botÃ³n mÃ¡s, el contador sigue incrementÃ¡ndose en uno cada segundo. Â¿QuÃ© pasa con este cÃ³digo? Â¿Por quÃ© `increment` es siempre igual a `1` dentro del cÃ³digo del Efecto? Encuentra el error y arrÃ©glalo.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <h1>
        Contador: {count}
        <button onClick={() => setCount(0)}>Reiniciar</button>
      </h1>
      <hr />
      <p>
        Cada segundo, incrementar en:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

Muestra al contador incrementÃ¡ndose en uno cada segundo, sin importar cuantas veces incrementemos o disminuyamos dicho incremento:

![[6.1-separar-eventos-de-efectos-1.png]]

### Respuesta

Como de costumbre, cuando busques bugs en Efectos, empieza por buscar supresiones de linters.

Si eliminas el comentario de supresiÃ³n, React te dirÃ¡ que el cÃ³digo de este Efecto depende de `increment`, pero tÃº le Â«mentisteÂ» a React afirmando que este Efecto no depende de ningÃºn valor reactivo (`[]`). AÃ±ade `increment` al array de dependencias:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, [increment]); // ðŸ‘ˆ

  return (
    <>
      <h1>
        Contador: {count}
        <button onClick={() => setCount(0)}>Reiniciar</button>
      </h1>
      <hr />
      <p>
        Cada segundo, incrementar en:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

Ahora si podemos incrementar el contador cada segundo por el incremento que queramos:

![[6.1-separar-eventos-de-efectos-2.png]]

Ahora, cuando `increment` cambie, React resincronizarÃ¡ tu Efecto, lo que reiniciarÃ¡ el intervalo.

## ðŸŒŸ DesafÃ­oÂ 2Â deÂ 4:Â Arreglar un contador congelado

Este componente `Timer` mantiene una variable de estado `count` que se incrementa cada segundo. El valor por el que aumenta se almacena en la variable de estado `increment`, que puedes controlar con los botones mÃ¡s y menos. Por ejemplo, prueba a pulsar el botÃ³n mÃ¡s nueve veces, y observa que la Â«cuentaÂ» ahora aumenta cada segundo por diez en lugar de por uno.

**Hay un pequeÃ±o problema con esta interfaz de usuario. Si pulsas los botones mÃ¡s de una vez por segundo, el temporizador parece detenerse. Solo se reanuda cuando ha pasado un segundo desde la Ãºltima vez que pulsaste cualquiera de los botones**. Averigua por quÃ© ocurre esto y soluciona el problema para que el temporizador marque _cada_ segundo sin interrupciones.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, [increment]);

  return (
    <>
      <h1>
        Contador: {count}
        <button onClick={() => setCount(0)}>Reiniciar</button>
      </h1>
      <hr />
      <p>
        Cada segundo, incrementar en:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

Muestra al contador incrementÃ¡ndose con el intervalo correcto, pero esperando a que se termine de pulsar un botÃ³n para continuar con el contador:


![[6.1-separar-eventos-de-efectos-1.png]]

### Respuesta

**El problema es que el cÃ³digo dentro del Efecto utiliza la variable de estado `increment`. Dado que es una dependencia de su Efecto, cada cambio en `increment` hace que el Efecto se vuelva a sincronizar, lo que hace que el intervalo se borre. Si sigues borrando el intervalo cada vez antes de que tenga la oportunidad de dispararse, parecerÃ¡ como si el temporizador se hubiera estancado**.

**Para resolver el problema, extrae un Evento de Efecto `onTick` del Efecto**:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  const onTick = useEffectEvent(() => { // ðŸ‘ˆ
    setCount(c => c + increment); // ðŸ‘ˆ
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick()
    }, 1000);
    return () => {
      clearInterval(id);
    };
  }, []); // ðŸ‘ˆ

  return (
    <>
      <h1>
        Contador: {count}
        <button onClick={() => setCount(0)}>Reiniciar</button>
      </h1>
      <hr />
      <p>
        Cada segundo, incrementar en:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

## DesafÃ­oÂ 3Â deÂ 4: Fijar un retraso no ajustable

En este ejemplo, puede personalizar el intervalo de retraso. Se almacena en una variable de estado `delay` que se actualiza mediante dos botones. Sin embargo, **aunque pulses el botÃ³n Â«mÃ¡s 100 msÂ» hasta que el `delay` sea de 1000 milisegundos (es decir, un segundo), notarÃ¡s que el temporizador sigue incrementÃ¡ndose muy rÃ¡pido (cada 100 ms). Es como si tus cambios en el `delay` fueran ignorados**. Encuentra y corrige el error.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);
  const [delay, setDelay] = useState(100);

  const onTick = useEffectEvent(() => {
    setCount(c => c + increment);
  });

  const onMount = useEffectEvent(() => {
    return setInterval(() => {
      onTick();
    }, delay);
  });

  useEffect(() => {
    const id = onMount();
    return () => {
      clearInterval(id);
    }
  }, []);

  return (
    <>
      <h1>
        Contador: {count}
        <button onClick={() => setCount(0)}>Reiniciar</button>
      </h1>
      <hr />
      <p>
        Incrementar en:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
      <p>
        Retraso de incremento:
        <button disabled={delay === 100} onClick={() => {
          setDelay(d => d - 100);
        }}>â€“100 ms</button>
        <b>{delay} ms</b>
        <button onClick={() => {
          setDelay(d => d + 100);
        }}>+100 ms</button>
      </p>
    </>
  );
}
```

Muestra:

![[6.1-separar-eventos-de-efectos-3.png]]

### Respuesta

El problema con el ejemplo anterior es que **extrajo un Evento de Efecto llamado `onMount` sin considerar lo que el cÃ³digo deberÃ­a estar haciendo realmente**. **==Solo deberÃ­as extraer Eventos de Efecto por una razÃ³n especÃ­fica: cuando quieres hacer que una parte de tu cÃ³digo no sea reactiva==**. **Sin embargo, la llamada a `setInterval` _deberÃ­a_ ser reactiva con respecto a la variable de estado `delay`. Si `delay` cambia, Â¡quieres configurar el intervalo desde cero!** Para arreglar este cÃ³digo, vuelve a meter todo el cÃ³digo reactivo dentro del Efecto:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);
  const [delay, setDelay] = useState(100);

  const onTick = useEffectEvent(() => {
    setCount(c => c + increment);
  });

  useEffect(() => {
    const id = setInterval(() => { // ðŸ‘ˆ
      onTick(); // ðŸ‘ˆ
    }, delay); // ðŸ‘ˆ
    return () => {
      clearInterval(id); // ðŸ‘ˆ
    }
  }, [delay]); // ðŸ‘ˆ

  return (
    <>
      <h1>
        Contador: {count}
        <button onClick={() => setCount(0)}>Reiniciar</button>
      </h1>
      <hr />
      <p>
        Incrementar en:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>â€“</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
      <p>
        Retraso de incremento:
        <button disabled={delay === 100} onClick={() => {
          setDelay(d => d - 100);
        }}>â€“100 ms</button>
        <b>{delay} ms</b>
        <button onClick={() => {
          setDelay(d => d + 100);
        }}>+100 ms</button>
      </p>
    </>
  );
}
```

En general, deberÃ­as desconfiar de funciones como `onMount` que se centran en el _tiempo_ mÃ¡s que en el _propÃ³sito_ de un trozo de cÃ³digo. Puede parecer Â«mÃ¡s descriptivoÂ» al principio, pero oscurece tu intenciÃ³n. **Como regla general, los Eventos de Efecto deberÃ­an corresponder a algo que ocurre desde la perspectiva del _usuario_. Por ejemplo, `onMessage`, `onTick`, `onVisit`, o `onConnected` son buenos nombres de Eventos de Efecto**. El cÃ³digo dentro de ellos probablemente no necesitarÃ­a ser reactivo. **Por otro lado, `onMount`, `onUpdate`, `onUnmount`, o `onAfterRender` son tan genÃ©ricos que es fÃ¡cil poner accidentalmente cÃ³digo que _deberÃ­a_ ser reactivo en ellos. Esta es la razÃ³n por la que deberÃ­as nombrar tus Eventos de Efecto despuÃ©s de _lo que el usuario piensa que ha pasado,_ no cuando algÃºn cÃ³digo se ha ejecutado**.

## ðŸŒŸ DesafÃ­oÂ 4Â deÂ 4:Â Arreglar una notificaciÃ³n con retrasoÂ 

Al entrar en una sala de chat, este componente muestra una notificaciÃ³n. Sin embargo, no muestra la notificaciÃ³n inmediatamente. En su lugar, la notificaciÃ³n se retrasa artificialmente dos segundos para que el usuario tenga la oportunidad de echar un vistazo a la interfaz de usuario.

Esto casi funciona, pero hay un error. **Intenta cambiar el menÃº desplegable de Â«generalÂ» a Â«viajeÂ» y luego a Â«mÃºsicaÂ» rÃ¡pidamente. Si lo haces lo suficientemente rÃ¡pido, verÃ¡s dos notificaciones (Â¡como era de esperar!) pero _ambas_ dirÃ¡n Â«Bienvenido a la mÃºsicaÂ»**.

ArrÃ©glalo para que cuando cambies de Â«generalÂ» a Â«viajeÂ» y luego a Â«mÃºsicaÂ» muy rÃ¡pidamente, veas dos notificaciones, la primera sea Â«Bienvenido a viajeÂ» y la segunda Â«Bienvenido a mÃºsicaÂ». (Para un reto adicional, suponiendo que _ya_ has hecho que las notificaciones muestren las salas correctas, cambia el cÃ³digo para que solo se muestre la Ãºltima notificaciÃ³n).

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Bienvenido a ' + roomId, theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      setTimeout(() => {
        onConnected();
      }, 2000);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Â¡Bienvenido a la sala {roomId}!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Elija la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="mÃºsica">mÃºsica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Utilizar un tema oscuro
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

**chat.js**
```js
export function createConnection(serverUrl, roomId) {
  // Una aplicaciÃ³n real se conectarÃ­a al servidor
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('Cannot add the handler twice.');
      }
      if (event !== 'connected') {
        throw Error('Solo se admite el evento "connected".');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

Muestra ambas notificaciones al cambiar de sala muy rapido pero con el texto de la Ãºltima seleccionada:

![[6.1-separar-eventos-de-efectos-4.png]]

### Respuesta

Dentro de tu Evento de Efecto, `roomId` es el valor _en el momento en que el Evento de Efecto fue llamado._

Su Evento de Efecto es llamado con un retraso de dos segundos. Si estÃ¡s cambiando rÃ¡pidamente de la sala de viaje a la sala de mÃºsica, en el momento en que se muestra la notificaciÃ³n de la sala de viaje, `roomId` ya es `"mÃºsica"`. Por eso ambas notificaciones dicen Â«Bienvenido a mÃºsicaÂ».

**Para solucionar el problema, en lugar de leer el _latest_ `roomId` dentro del Evento de Efecto, hazlo un parÃ¡metro de tu Evento de Efecto, como `connectedRoomId` abajo. Luego pasa `roomId` desde tu Efecto llamando a `onConnected(roomId)`**:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent((roomId) => { // ðŸ‘ˆ
    showNotification('Bienvenido a ' + roomId, theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      setTimeout(() => {
        onConnected(roomId); // ðŸ‘ˆ
      }, 2000);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ðŸ‘ˆ

  return <h1>Â¡Bienvenido a la sala {roomId}!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Elija la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="mÃºsica">mÃºsica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Utilizar un tema oscuro
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

El Efecto que tenÃ­a `roomId` como `"viaje"` (por lo que se conectÃ³ a la sala `"viaje"`) mostrarÃ¡ la notificaciÃ³n de `"viaje"`. El Efecto que tiene `roomId` como `"mÃºsica"` (por lo que se conectÃ³ a la sala `"mÃºsica"`) mostrarÃ¡ la notificaciÃ³n de `"mÃºsica"`. En otras palabras, **==`connectedRoomId` viene de tu Efecto (que es reactivo), mientras que `theme` siempre utiliza el Ãºltimo valor==**.

**Para resolver el problema adicional, guarda el ID del tiempo de espera de la notificaciÃ³n y elimÃ­nalo en la funciÃ³n de limpieza de tu Efecto**:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(connectedRoomId => {
    showNotification('Bienvenido a ' + connectedRoomId, theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    let notificationTimeoutId; // ðŸ‘ˆ
    connection.on('connected', () => {
      notificationTimeoutId = setTimeout(() => {
        onConnected(roomId);
      }, 2000);
    });
    connection.connect();
    return () => {
      connection.disconnect();
      if (!notificationTimeoutId)  // ðŸ‘ˆ
        clearTimeout(notificationTimeoutId); // ðŸ‘ˆ
    };
  }, [roomId]);

  return <h1>Â¡Bienvenido a la sala {roomId}!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Elija la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="mÃºsica">mÃºsica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Utilizar un tema oscuro
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

**Esto garantiza que las notificaciones ya programadas (pero aÃºn no mostradas) se cancelen cuando cambie de sala**.

