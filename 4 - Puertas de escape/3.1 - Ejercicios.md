## DesafÃ­oÂ 1Â deÂ 4:Â Enfoca un campo en montajeÂ 

En este ejemplo, el formulario renderiza un componente `<MyInput />`.

Usa el mÃ©todo [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) del input para hacer que `MyInput` se enfoque automÃ¡ticamente cuando aparece en pantalla. Ya hay una implementaciÃ³n comentada, pero no funciona correctamente. Descubre por quÃ© no funciona y corrÃ­gelo. (Si estÃ¡s familiarizado con el atributo `autoFocus`, pretende que no existe: estamos reimplementando la misma funcionalidad desde cero.)

**MyInput.js**
```jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  // TODO: Esto no funciona del todo. CorrÃ­gelo.
  // ref.current.focus()    

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

Muestra:

![[3.1-sincronizar-con-efectos-1.png]]

Al pulsar el botÃ³n se muestra el componente, pero no se enfoca el input automÃ¡ticamente:

![[3.1-sincronizar-con-efectos-2.png]]

Para verificar que tu soluciÃ³n funciona, presiona Â«Mostrar formularioÂ» y verifica que el input reciba enfoque (Se resalta y se coloca el cursor dentro). Presiona Â«Ocultar formularioÂ» y luego Â«Mostrar formularioÂ» nuevamente. Verifica que el input se resalte nuevamente.

`MyInput` deberÃ­a enfocarse solo _en el montaje_ en lugar de despuÃ©s de cada renderizado. Para comprobar que el comportamiento es correcto, presiona repetidamente la casilla Â«Ponerlo en mayÃºsculasÂ». Hacer clic en la casilla de verificaciÃ³n no deberÃ­a enfocar el input encima de ella.

### Respuesta

Llamar a `ref.current.focus()` durante el renderizado estÃ¡ mal porque es un _efecto secundario_. Los efectos secundarios deben ser definidos dentro de un controlador de evento o declarados con `useEffect`. En este caso, el efecto secundario es _causado_ por la apariciÃ³n del componente en vez de alguna interacciÃ³n especÃ­fica, por lo tanto tiene sentido ponerlo dentro de un Efecto.

Para solucionar el error, envuelve la llamada `ref.current.focus()` dentro de un Efecto. Luego, para asegurarte que este Efecto se ejecute solo en el montaje en vez de despuÃ©s de cada renderizado, aÃ±ade el array de dependencias vacÃ­o `[]`.

**MyInput.jsx**
```jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  useEffect(() => { // ğŸ‘ˆ
    ref.current.focus(); // ğŸ‘ˆ
  }, []); // ğŸ‘ˆ

  return (
    <input
      ref={ref} ğŸ‘ˆ
      value={value}
      onChange={onChange}
    />
  );
}
```

Ahora el input se infoca automÃ¡ticamente al montarse el componente:

![[3.1-sincronizar-con-efectos-3.png]]

## DesafÃ­oÂ 2Â deÂ 4:Â Enfoca un campo condicionalmenteÂ 

Este formulario renderiza dos componentes `<MyInput />`.

Presiona Â«Mostrar formularioÂ» y observa que el segundo campo obtiene automÃ¡ticamente el enfoque. Esto se debe a que ambos componentes `<MyInput />` intentan enfocar el campo interno. Cuando llamas a `focus()` para dos inputs consecutivos, siempre Â«ganaÂ» el Ãºltimo.

Supongamos que quieres enfocar el primer campo. Ahora el primer componente `MyInput` recibe una prop booleana `shouldFocus` establecida en `true`. Cambia la lÃ³gica para que `focus()` sea llamado solo si la prop `shouldFocus` recibida por `MyInput` es `true`.

**MyInput.jsx**
```jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  // TODO: llama a focus() solo si shouldFocus es true.
  useEffect(() => {
    ref.current.focus();
  }, []);

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

Muestra:

![[3.1-sincronizar-con-efectos-4.png]]

Al presionar sobre el botÃ³n, se enfoca el segundo input, cuando deberÃ­a ser el primero:

![[3.1-sincronizar-con-efectos-5.png]]

Para verificar tu soluciÃ³n, presiona Â«Mostrar formularioÂ» y Â«Ocultar formularioÂ» repetidamente. Cuando aparezca el formulario, solo el _primer_ campo debe recibir el enfoque. Esto se debe a que el componente padre renderiza el primer campo con `shouldFocus={true}` y el segundo con `shouldFocus={false}`. TambiÃ©n verifica que ambos campos sigan funcionando y se pueda escribir en ambos.

### Respuesta

Coloca la lÃ³gica condicional dentro del Efecto. Necesitas especificar `shouldFocus` como una dependencia porque lo estÃ¡s usando dentro del Efecto. (Esto significa que si el `shouldFocus` cambia de `false` a `true`, se enfocarÃ¡ despuÃ©s del montaje.)

```jsx
import { useEffect, useRef } from 'react';

export default function MyInput({ shouldFocus, value, onChange }) {
  const ref = useRef(null);

  // TODO: llama a focus() solo si shouldFocus es true.
  useEffect(() => {
    if (shouldFocus) ref.current.focus(); // ğŸ‘ˆ
  }, [shouldFocus]); // ğŸ‘ˆ

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

## â­ DesafÃ­oÂ 3Â deÂ 4:Â Arregla un intervalo que se ejecuta dos veces

El componente `Counter` muestra un contador que debe incrementarse cada segundo. Durante el montaje, llama a [`setInterval`.](https://developer.mozilla.org/es/docs/Web/API/setInterval) Esto causa que se ejecute `onTick` cada segundo. La funciÃ³n `onTick` incrementa el contador.

Sin embargo, en vez de incrementarlo una vez por segundo, lo incrementa dos veces. Â¿Por quÃ© sucede esto? Encuentra la causa del error y corrÃ­gelo.

**Counter.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount(c => c + 1);
    }

    setInterval(onTick, 1000);
  }, []);

  return <h1>{count}</h1>;
}
```

Muestra:

![[3.1-sincronizar-con-efectos-4.png]]

A penas se pulsa el botÃ³n el componente se monta, pero el contador empieza a contar de dos en dos:

![[3.1-sincronizar-con-efectos-6.png]]

### Respuesta

Cuando el [Modo Estricto](https://es.react.dev/reference/react/StrictMode) estÃ¡ activo (como en las sandboxes de este sitio), React vuelve a montar cada componente de nuevo en desarrollo. Esto causa que el intervalo se configure dos veces, y por eso el contador se incrementa dos veces cada segundo.

Sin embargo, **el comportamiento de React no es la _causa_ del error: el error ya existe en el cÃ³digo. El comportamiento de React hace que el error sea mÃ¡s notable. La causa real es que este Efecto inicia un proceso pero no proporciona una forma de limpiarlo**.

Para arreglar este cÃ³digo, guarda el ID del intervalo devuelto por `setInterval`, e implementa una funciÃ³n de limpieza con [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval):

**Counter.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    function onTick() {
      setCount(c => c + 1);
    }

    const intervalId = setInterval(onTick, 1000); // ğŸ‘ˆ
    return () => clearInterval(intervalId); // ğŸ‘ˆ
  }, []);

  return <h1>{count}</h1>;
}
```

En desarrollo, React seguirÃ¡ montando el componente una vez para verificar que hayas implementado bien la limpieza. Por lo tanto, habrÃ¡ una llamada a `setInterval`, seguida inmediatamente por `clearInterval` y nuevamente `setInterval`. En producciÃ³n, solo habrÃ¡ una llamada a `setInterval`. El comportamiento visible para el usuario en ambos casos es el mismo: el contador se incrementa una vez por segundo.

## â­ DesafÃ­oÂ 4Â deÂ 4:Â Arregla la solicitud dentro de un Efecto

Este componente muestra la biografÃ­a de la persona seleccionada. Carga la biografÃ­a llamando a una funciÃ³n asÃ­ncrona `fetchBio(person)` al montar y cuando `person` cambia. Esa funciÃ³n asÃ­ncrona devuelve una [promesa](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise) que eventualmente se resuelve a un string. Cuando la solicitud estÃ¡ hecha, se llama a `setBio` para mostrar el string debajo del elemento select.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);

  useEffect(() => {
    setBio(null);
    fetchBio(person).then(result => {
      setBio(result);
    });
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}
```
Muestra

![[Pasted image 20240625171218.png]]

Si seleccionamos a "Bob" (cuya promesa tarda mucho en resolverse) y cambiamos rÃ¡pidamente a "Taylor", vemos que inicialmente se nos mostrarÃ¡ la biografÃ­a de "Taylor", pero tiempo despuÃ©s se nos mostrarÃ¡ la biografÃ­a de "Bob", esto porque fue la Ãºltima promesa en resolverse, y que al hacerlo, insertamos la info en el estado:

![[3.1-sincronizar-con-efectos-7.png]]


Hay un error en este cÃ³digo. Comienza seleccionando Â«AliceÂ». Luego selecciona Â«BobÂ» y luego inmediatamente selecciona Â«TaylorÂ». Si lo haces lo suficientemente rÃ¡pido, notarÃ¡s el error: Taylor estÃ¡ seleccionado, pero el texto de abajo dice Â«Esta es la biografÃ­a de BobÂ».

Â¿Por quÃ© sucede esto? Corrige el error dentro de este Efecto.

### Respuesta

Para desencadenar el error, las cosas deben ocurrir en el siguiente orden:

- SeleccionarÂ `'Bob'`Â desencadenaÂ `fetchBio('Bob')`
- SeleccionarÂ `'Taylor'`Â desencadenaÂ `fetchBio('Taylor')`
- **La solicitud paraÂ `'Taylor'`Â se completaÂ _antes_Â que la solicitud paraÂ `'Bob'`**
- El Efecto del renderizado deÂ `'Taylor'`Â llama aÂ `setBio('Esta es la biografÃ­a de Taylor.')`
- La solicitud paraÂ `'Bob'`Â se completa
- El Efecto del renderizado deÂ `'Bob'`Â llama aÂ `setBio('Esta es la biografÃ­a de Bob.')`

Esto es porque ves la biografÃ­a de Bob incluso si la de Taylor es la que estÃ¡ seleccionada. Estos errores son llamados [condiciones de carrera](https://es.wikipedia.org/wiki/Condici%C3%B3n_de_carrera) porque dos operaciones asÃ­ncronas estÃ¡n Â«compitiendoÂ» entre sÃ­ y podrÃ­an llegar en un orden inesperado.

Para solucionar esta condiciÃ³n de carrera, aÃ±ade una funciÃ³n de limpieza:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);

  useEffect(() => {
    setBio(null);
    let ignoreFetch = false; // ğŸ‘ˆ
    fetchBio(person).then(result => {
      if (!ignoreFetch) setBio(result); // ğŸ‘ˆ
    });

    return () => ignoreFetch = true // ğŸ‘ˆ
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}
```

El Efecto de cada uno de los renderizados tiene su propia variable `ignore`. Inicialmente, la variable `ignore` es `false`. Sin embargo, si un Efecto hace una limpieza (como cuando seleccionas una persona diferente), su variable `ignore` pasa a ser `true`. Entonces, ahora no importa en quÃ© orden se completen las solicitudes. Solo el Efecto de la Ãºltima persona tendrÃ¡ `ignore` configurado como `false`, por lo que llamarÃ¡ a `setBio(result)`. Los Efectos anteriores han sido limpiados, por lo que la comprobaciÃ³n `if (!ignore)` evitarÃ¡ que llamen a `setBio`:

- Seleccionar aÂ `'Bob'`Â desencadenaÂ `fetchBio('Bob')`
- Seleccionar aÂ `'Taylor'`Â desencadenaÂ `fetchBio('Taylor')`Â **y limpia el anterior Efecto (de Bob)**
- La solicitud paraÂ `'Taylor'`Â se completaÂ _antes_Â que la solicitud paraÂ `'Bob'`
- El Efecto del renderizado deÂ `'Taylor'`Â llama aÂ `setBio('Esta es la biografÃ­a de Taylor.')`
- La solicitud paraÂ `'Bob'`Â se completa
- El Efecto del renderizado deÂ `'Bob'`Â **no hace nada porque su variableÂ `ignore`Â fue definida comoÂ `true`**

Para ignorar el resultado de una llamada de API desactualizada, tambiÃ©n puedes usar [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) para cancelar solicitudes que ya no son necesarias. Sin embargo, por sÃ­ solo esto no es suficiente para protegerse contra las condiciones de carrera. Se podrÃ­an encadenar mÃ¡s pasos asÃ­ncronos despuÃ©s del fetch, por lo que el uso de una bandera explÃ­cita como `ignore` es la forma mÃ¡s confiable de solucionar este tipo de problemas.