## â­ DesafÃ­oÂ 1Â deÂ 4:Â Arregla un input de chat roto

Escribe un mensaje y haz clic en Â«EnviarÂ». NotarÃ¡s que hay un retraso de tres segundos antes de que veas la alerta de Â«Â¡Enviado!Â«. Durante este retraso, puedes ver un botÃ³n de Â«DeshacerÂ». Haz clic en Ã©l. Este botÃ³n de Â«DeshacerÂ» se supone que debe evitar que el mensaje de Â«Â¡Enviado!Â» aparezca. Hace esto llamando a [`clearTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout) para el identificador del timeout guardado durante `handleSend`. Sin embargo, incluso despuÃ©s de hacer clic en Â«DeshacerÂ», el mensaje de Â«Â¡Enviado!Â» sigue apareciendo. Encuentra por quÃ© no funciona, y arrÃ©glalo.

**App.jsx**
```jsx
import { useState } from 'react';

export default function Chat() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  let timeoutID = null;

  function handleSend() {
    setIsSending(true);
    timeoutID = setTimeout(() => {
      alert('Â¡Enviado!');
      setIsSending(false);
    }, 3000);
  }

  function handleUndo() {
    setIsSending(false);
    clearTimeout(timeoutID);
  }

  return (
    <>
      <input
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button
        disabled={isSending}
        onClick={handleSend}>
        {isSending ? 'Enviando...' : 'Enviar'}
      </button>
      {isSending &&
        <button onClick={handleUndo}>
          Deshacer
        </button>
      }
    </>
  );
}
```

Muestra:

![[1.1-referenciar-valores-con-refs-1.png]]

Al pulsar el botÃ³n "Enviar" muestra: 

![[1.1-referenciar-valores-con-refs-2.png]]
Al pulsar en el botÃ³n "Deshacer", al pasar 3 segundo igual muestra el siguiente alert:

![[1.1-referenciar-valores-con-refs-3.png]]

### Respuesta

**Sin importar cuÃ¡ndo tu componente se rerenderice (como cuando asignas el estado), todas las variables locales se inicializan desde cero. Por eso es que no puedes guardar el identificador del timeout en una variable local como `timeoutID` y luego esperar que otro controlador de evento lo Â«veaÂ» en el futuro**. En cambio, almacÃ©nalo en una ref, que React preservarÃ¡ entre renderizados.

**App.jsx**
```jsx
import { useState, useRef } from 'react'; // ğŸ‘ˆ

export default function Chat() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  let timeoutID = useRef(null); // ğŸ‘ˆ

  function handleSend() {
    setIsSending(true);
    timeoutID.current = setTimeout(() => { // ğŸ‘ˆ
      alert('Â¡Enviado!');
      setIsSending(false);
    }, 3000);
  }

  function handleUndo() {
    setIsSending(false);
    clearTimeout(timeoutID.current); // ğŸ‘ˆ
  }

  return (
    <>
      <input
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button
        disabled={isSending}
        onClick={handleSend}>
        {isSending ? 'Enviando...' : 'Enviar'}
      </button>
      {isSending &&
        <button onClick={handleUndo}>
          Deshacer
        </button>
      }
    </>
  );
}
```

## DesafÃ­oÂ 2Â deÂ 4:Â 

Arregla un componente que no logra rerenderizar

Este botÃ³n se supone que alterna entre mostrar Â«EncendidoÂ» y Â«ApagadoÂ». Sin embargo, siempre muestra Â«ApagadoÂ». Â¿QuÃ© estÃ¡ mal en este cÃ³digo? ArrÃ©glalo.

**App.jsx**
```jsx
import { useRef } from 'react';

export default function Toggle() {
  const isOnRef = useRef(false);

  return (
    <button onClick={() => {
      isOnRef.current = !isOnRef.current;
    }}>
      {isOnRef.current ? 'Encendido' : 'Apagado'}
    </button>
  );
}
```

Muestra:

![[1.1-referenciar-valores-con-refs-4.png]]

Si pulsamos en el botÃ³n, el texto no cambia

![[1.1-referenciar-valores-con-refs-4.png]]

### Respuesta

**App.jsx**
```jsx
import { useState } from 'react';

export default function Toggle() {
  const [isOn, setIsOn] = useState(false); // ğŸ‘ˆ

  return (
    <button onClick={() => {
      setIsOn(!isOn); // ğŸ‘ˆ
    }}>
      {isOn ? 'Encendido' : 'Apagado'} // ğŸ‘ˆ
    </button>
  );
}
```

Al pulsar el botÃ³n ahora el texto en este cambia:

![[1.1-referenciar-valores-con-refs-5.png]]
\
## â­ DesafÃ­oÂ 3Â deÂ 4:Â Arregla elÂ _debounce_

**En este ejemplo, todos los controladores de clic usan [el Â«corte de reboteÂ» o _Â«debounceÂ»_.](https://redd.one/blog/debounce-vs-throttle)** Para ver que significa esto, presiona uno de los botones. FÃ­jate como el mensaje aparece un segundo despuÃ©s. Si presionas el botÃ³n mientras esperas el mensaje, el temporizador se reiniciarÃ¡. AsÃ­ que si te mantienes cliqueando el mismo botÃ³n rÃ¡pidamente muchas veces, el mensaje no aparecerÃ¡ hasta un segundo _despuÃ©s_ de que pares de hacer clic. **El _debounce_ te permite retrasar algunas acciones hasta que el usuario Â«pare de hacer cosasÂ»**.

Este ejemplo funciona, pero no tan bien como se esperaba. Los botones no son independientes. Para ver el problema, haz clic en uno de los botones, y luego inmediatamente haz clic en otro botÃ³n. EsperarÃ­as que despuÃ©s de un retraso, podrÃ­as ver los mensajes de ambos botones. Pero solo se muestra el mensaje del Ãºltimo botÃ³n. El mensaje del primer botÃ³n se pierde.

Â¿Por quÃ© los botones estÃ¡n interfiriendo con los demÃ¡s? Encuentra y arregla el problema.

**App.jsx**
```jsx
let timeoutID;

function DebouncedButton({ onClick, children }) {
  return (
    <button onClick={() => {
      clearTimeout(timeoutID);
      timeoutID = setTimeout(() => {
        onClick();
      }, 1000);
    }}>
      {children}
    </button>
  );
}

export default function Dashboard() {
  return (
    <>
      <DebouncedButton
        onClick={() => alert('Â¡Cohete lanzado!')}
      >
        Lanza el cohete
      </DebouncedButton>
      <DebouncedButton
        onClick={() => alert('Â¡Sopa hervida!')}
      >
        Hierve la sopa
      </DebouncedButton>
      <DebouncedButton
        onClick={() => alert('Â¡CanciÃ³n de cuna cantada!')}
      >
        Canta una canciÃ³n de cuna
      </DebouncedButton>
    </>
  )
}
```

Muestra:

![[1.1-referenciar-valores-con-refs-6.png]]

Al pulsar un butÃ³n y e inmediatamente durante el retraso se pulsa otro botÃ³n, al segundo sÃ³lo se mostrarÃ¡ el mensaje del ultimo botÃ³n pulsado (en este caso "Hierve la sopa"):

![[1.1-referenciar-valores-con-refs-7.png]]

### Respuesta:

Una variable como `timeoutID` se comparte entre todos los componentes. Por esto si se hace clic en el segundo botÃ³n se reinicia el timeout pendiente del primer botÃ³n. Para solucionarlo, puedes guardar el timeout en una ref. Cada botÃ³n tendrÃ¡ su propia ref, asÃ­ no tendrÃ¡n conflicto con los demÃ¡s botones. FÃ­jate como al hacer clic a dos botones rÃ¡pidamente se mostrarÃ¡n ambos mensajes.

**App.jsx**
```jsx
import { useRef } from 'react' // ğŸ‘ˆ

function DebouncedButton({ onClick, children }) {
  const timeoutID = useRef(null) // ğŸ‘ˆ
  return (
    <button onClick={() => {
      clearTimeout(timeoutID.current); // ğŸ‘ˆ
      timeoutID.current = setTimeout(() => { // ğŸ‘ˆ
        onClick();
      }, 1000);
    }}>
      {children}
    </button>
  );
}

export default function Dashboard() {
  return (
    <>
      <DebouncedButton
        onClick={() => alert('Â¡Cohete lanzado!')}
      >
        Lanza el cohete
      </DebouncedButton>
      <DebouncedButton
        onClick={() => alert('Â¡Sopa hervida!')}
      >
        Hierve la sopa
      </DebouncedButton>
      <DebouncedButton
        onClick={() => alert('Â¡CanciÃ³n de cuna cantada!')}
      >
        Canta una canciÃ³n de cuna
      </DebouncedButton>
    </>
  )
}
```
Primer mensaje:

![[1.1-referenciar-valores-con-refs-8.png]]

Segundo mensaje:

![[1.1-referenciar-valores-con-refs-7.png]]

## DesafÃ­oÂ 4Â deÂ 4:Â Lee el Ãºltimo estado

En este ejemplo, despuÃ©s de que presionas Â«EnviarÂ», hay un pequeÃ±o retraso antes de que el mensaje se muestre. Escribe Â«holaÂ», presiona Enviar, y luego rÃ¡pidamente edita el input otra vez. A pesar de tus cambios, la alerta seguirÃ¡ mostrando Â«holaÂ» (que fue el valor del estado [en el momento](https://es.react.dev/learn/state-as-a-snapshot#state-over-time) en el que hiciste clic en el botÃ³n).

Normalmente, este es el comportamiento que quieres en una aplicaciÃ³n. Sin embargo, en ocasiones quieres que algÃºn cÃ³digo asÃ­ncrono lea la _Ãºltima_ versiÃ³n de algÃºn estado. Â¿Se te ocurre alguna manera de hacer que la alerta muestre el texto _actual_ del input en lugar del que estaba en el momento del clic?

**App.jsx**
```jsx
import { useState, useRef } from 'react';

export default function Chat() {
  const [text, setText] = useState('');

  function handleSend() {
    setTimeout(() => {
      alert('Enviando: ' + text);
    }, 3000);
  }

  return (
    <>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button
        onClick={handleSend}>
        Enviar
      </button>
    </>
  );
}
```

Muestra:

![[1.1-referenciar-valores-con-refs-9.png]]

Al pulsar enviar, editamos inmediatamente el mensaje:

![[1.1-referenciar-valores-con-refs-10.png]]

AÃºn asÃ­, un segundo despuÃ©s vemos que se muestra un alert con el mensaje original:

![[1.1-referenciar-valores-con-refs-11.png]]

### Respuesta

**El estado funciona [como una instantÃ¡nea](https://es.react.dev/learn/state-as-a-snapshot), asÃ­ que no puedes leer el Ãºltimo estado de una operaciÃ³n asÃ­ncrona como un timeout**. 

Sin embargo, **puedes guardar el Ãºltimo texto del input en una ref. Una ref es mutable, asÃ­ que puedes leer la propiedad `current` en cualquier momento**. Como el texto actual tambiÃ©n se usa para el renderizado, en este ejemplo, necesitaras _tanto_ una variable de estado (para el renderizado), _como_ una ref (para leerlo en el timeout). NecesitarÃ¡s actualizar el valor actual de la ref manualmente.

**App.jsx**
```jsx
import { useState, useRef } from 'react';

export default function Chat() {
  const [text, setText] = useState('');
  const textRef = useRef(''); // ğŸ‘ˆ

  function handleChange(e) { // ğŸ‘ˆ
    setText(e.target.value)
    textRef.current = e.target.value // ğŸ‘ˆ
  }
  function handleSend() {
    setTimeout(() => {
      alert('Enviando: ' + textRef.current); // ğŸ‘ˆ
    }, 3000);
  }

  return (
    <>
      <input
        value={text}
        onChange={handleChange} // ğŸ‘ˆ
      />
      <button
        onClick={e => handleSend(e)}>
        Enviar
      </button>
    </>
  );
}
```