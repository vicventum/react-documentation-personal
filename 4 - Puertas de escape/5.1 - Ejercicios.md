## Desaf√≠o¬†1¬†de¬†5:¬†Arreglar la reconexi√≥n en cada pulsaci√≥n de tecla

En este ejemplo, el componente `ChatRoom` se conecta a la sala de chat cuando el componente se monta, se desconecta cuando se desmonta y se vuelve a conectar cuando seleccionas una sala de chat diferente. Este comportamiento es correcto, por lo que debes mantenerlo funcionando.

Sin embargo, hay un problema. Cada vez que escribes en el cuadro de entrada de mensajes en la parte inferior, `ChatRoom` _tambi√©n_ se reconecta al chat. (Puedes notarlo borrando la consola y escribiendo en la entrada.) Arregla el problema para que esto no suceda.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  });

  return (
    <>
      <h1>¬°Bienvenido a la sala {roomId}!</h1>
      <input
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Escoge una sala:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

**chat.jsx**
```jsx
export function createConnection(serverUrl, roomId) {
  // Una implementaci√≥n real en realidad conectar√≠a al servidor
  return {
    connect() {
      console.log('‚úÖ Conectando a la sala "' + roomId + '" en ' + serverUrl + '...');
    },
    disconnect() {
      console.log('‚ùå Desconectado de la sala "' + roomId + '" en ' + serverUrl);
    }
  };
}
```

### Respuesta

Este Efecto no ten√≠a un _array_ de dependencias en absoluto, por lo que se volvi√≥ a sincronizar despu√©s de cada renderizado. Primero, agrega un _array_ de dependencias. Luego, aseg√∫rate de que cada valor reactivo utilizado por el Efecto est√© especificado en el _array_. Por ejemplo, `roomId` es reactivo (porque es una prop), por lo que debe incluirse en el _array_. Esto asegura que cuando el usuario selecciona una sala de chat diferente, el chat se reconecta. Por otro lado, `serverUrl` se define fuera del componente. Es por eso que no necesita estar en el _array_.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // üëà

  return (
    <>
      <h1>¬°Bienvenido a la sala {roomId}!</h1>
      <input
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Escoge una sala:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

## Desaf√≠o¬†2¬†de¬†5:¬†Activar y desactivar la sincronizaci√≥n

En este ejemplo, un Efecto se suscribe al evento de ventana [`pointermove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event) para mover un punto rosa en la pantalla. Intenta pasar el cursor sobre el √°rea de vista previa (o tocar la pantalla si est√°s en un dispositivo m√≥vil) y ve c√≥mo el punto rosa sigue tu movimiento.

Tambi√©n hay una casilla de verificaci√≥n. Al marcar la casilla, se cambia la variable de estado `canMove`, pero esta variable de estado no se usa en ninguna parte del c√≥digo. Tu tarea es cambiar el c√≥digo para que cuando `canMove` sea `false` (la casilla est√° desactivada), el punto deje de moverse. Despu√©s de volver a activar la casilla (y establecer `canMove` en `true`), la caja debe seguir el movimiento nuevamente. En otras palabras, si el punto puede moverse o no debe permanecer sincronizado con la marca de la casilla.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  useEffect(() => {
    function handleMove(e) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)} 
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

### Respuesta

Una soluci√≥n es envolver la llamada `setPosition` en una condici√≥n `if (canMove) { ... }`:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  useEffect(() => {
    function handleMove(e) {
      if (canMove) setPosition({ x: e.clientX, y: e.clientY }); // üëà
    }
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }, [canMove]); // üëà

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)} 
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

## Desaf√≠o¬†3¬†de¬†5:¬†Investiga un error de valor obsoleto¬†

En este ejemplo, el punto rosa deber√≠a moverse cuando el checkbox est√° activado, y deber√≠a dejar de moverse cuando el checkbox est√° desactivado. La l√≥gica para esto ya se ha implementado: el controlador de evento `handleMove` comprueba la variable de estado `canMove`.

Sin embargo, por alguna raz√≥n, la variable de estado `canMove` dentro de `handleMove` parece estar ¬´obsoleta¬ª: siempre es `true`, incluso despu√©s de desmarcar el checkbox. ¬øC√≥mo es posible esto? Encuentra el error en el c√≥digo y arr√©glalo.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)} 
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

El problema con el c√≥digo original era suprimir el linter de dependencias. Si eliminas la supresi√≥n, ver√°s que este Efecto depende de la funci√≥n `handleMove`. Esto tiene sentido: `handleMove` se declara dentro del cuerpo del componente, lo que lo convierte en un valor reactivo. Cada valor reactivo debe especificarse como una dependencia, o puede volverse obsoleto con el tiempo.

El autor del c√≥digo original le ha ¬´mentido¬ª a React diciendo que el Efecto no depende (`[]`) de ning√∫n valor reactivo. Por eso React no volvi√≥ a sincronizar el Efecto despu√©s de que `canMove` cambi√≥ (y `handleMove` con √©l). Como React no volvi√≥ a sincronizar el Efecto, el `handleMove` adjunto como oyente es la funci√≥n `handleMove` creada durante el renderizado inicial. Durante el renderizado inicial, `canMove` era `true`, por lo que `handleMove` del renderizado inicial siempre ver√° ese valor.

**Si nunca suprimes el linter, nunca ver√°s problemas con valores obsoletos.** Hay algunas formas diferentes de resolver este error, pero siempre debes comenzar eliminando la supresi√≥n del linter. Luego cambia el c√≥digo para corregir el error del linter.

Puedes cambiar las dependencias del Efecto a `[handleMove]`, pero como va a ser una funci√≥n reci√©n definida para cada renderizado, puedes eliminar por completo el _array_ de dependencias. Entonces el Efecto _se volver√° a sincronizar_ despu√©s de cada renderizado:

**App.js**
```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }); // üëà

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)} 
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

Esta soluci√≥n funciona, pero no es ideal. Si pones `console.log('Resubscribing')` dentro del Efecto, notar√°s que se vuelve a suscribir despu√©s de cada rerenderizado. La resuscripci√≥n es r√°pida, pero a√∫n as√≠ ser√≠a bueno evitar hacerlo tan a menudo.

Una mejor soluci√≥n ser√≠a mover la funci√≥n `handleMove` _dentro_ del Efecto. Entonces `handleMove` no ser√° un valor reactivo, por lo que tu Efecto no depender√° de una funci√≥n. En cambio, necesitar√° depender de `canMove` que ahora lee desde dentro del Efecto. Esto coincide con el comportamiento que deseabas, ya que tu Efecto ahora se mantendr√° sincronizado con el valor de `canMove`:

**App.js**
```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);
  
  useEffect(() => {
    function handleMove(e) { // üëà
      if (canMove) {
        setPosition({ x: e.clientX, y: e.clientY });
      }
    }
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
  }, [canMove]); // üëà

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)} 
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

Intenta agregar `console.log('Resubscribing')` dentro del cuerpo del Efecto y notar√°s que ahora solo se vuelve a suscribir cuando cambias el valor del checkbox (`canMove` cambia) o editas el c√≥digo. Esto lo hace mejor que el enfoque anterior que siempre se volv√≠a a suscribir.

Aprender√°s un enfoque m√°s general para este tipo de problema en [Separar Eventos de Efectos.](https://es.react.dev/learn/separating-events-from-effects)

## ‚≠ê Desaf√≠o¬†4¬†de¬†5:¬†Solucionar un cambio de conexi√≥n¬†

En este ejemplo, el servicio de chat en `chat.js` expone dos APIs diferentes: `createEncryptedConnection` y `createUnencryptedConnection`. El componente ra√≠z `App` permite al usuario elegir si usar o no la encriptaci√≥n, y luego pasa el m√©todo de API correspondiente al componente secundario `ChatRoom` como la prop `createConnection`.

Nota que inicialmente, los registros de la consola dicen que la conexi√≥n no est√° cifrada. Intenta cambiar el valor del checkbox: no suceder√° nada. Sin embargo, si cambias la sala de chat seleccionada despu√©s de eso, entonces el chat se reconectar√° _y_ habilitar√° la encriptaci√≥n (como ver√°s en los mensajes de la consola). Esto es un error. Arregla el error para que el cambio del checkbox _tambi√©n_ haga que el chat se reconecte.

**App.jsx**
```jsx
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';
import {
  createEncryptedConnection,
  createUnencryptedConnection,
} from './chat.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isEncrypted, setIsEncrypted] = useState(false);
  return (
    <>
      <label>
        Selecciona una sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isEncrypted}
          onChange={e => setIsEncrypted(e.target.checked)}
        />
        Activar encriptaci√≥n
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        createConnection={isEncrypted ?
          createEncryptedConnection :
          createUnencryptedConnection
        }
      />
    </>
  );
}
```

**ChatRoom.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function ChatRoom({ roomId, createConnection }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId]);

  return <h1>¬°Bienvenido a la sala {roomId}!</h1>;
}
```

**chat.js**
```jsx
export function createEncryptedConnection(roomId) {
  // Una implementaci√≥n real se conectar√≠a realmente al servidor 
  return {
    connect() {
      console.log('‚úÖ üîê Conectando a "' + roomId + '... (encriptado)');
    },
    disconnect() {
      console.log('‚ùå üîê Desconectando de la sala "' + roomId + '" (encriptado)');
    }
  };
}

export function createUnencryptedConnection(roomId) {
  // Una implementaci√≥n real se conectar√≠a realmente al servidor 
  return {
    connect() {
      console.log('‚úÖ Conectando a "' + roomId + '... (sin encriptado)');
    },
    disconnect() {
      console.log('‚ùå Desconectando de la sala "' + roomId + '" (sin encriptado)');
    }
  };
}
```

### Respuesta

Si quitas la supresi√≥n del linter, ver√°s un error de lint. El problema es que `createConnection` es una prop, por lo que es un valor reactivo. ¬°Puede cambiar con el tiempo! (Y de hecho, deber√≠a hacerlo, cuando el usuario marca el checkbox, el componente padre pasa un valor diferente de la prop `createConnection`). Por eso deber√≠a ser una dependencia. Incl√∫yelo en la lista para solucionar el error:

**ChatRoom.jsx**
```jsx
import { useState, useEffect } from 'react';

export default function ChatRoom({ roomId, createConnection }) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, createConnection]); // üëà

  return <h1>¬°Bienvenido a la sala {roomId}!</h1>;
}
```

Es correcto que `createConnection` sea una dependencia. **Sin embargo, este c√≥digo es un poco fr√°gil porque alguien podr√≠a editar el componente `App` para pasar una funci√≥n en l√≠nea como valor de esta prop. En ese caso, su valor ser√≠a diferente cada vez que el componente `App` se vuelva a renderizar, por lo que el Efecto podr√≠a volver a sincronizarse demasiado a menudo. Para evitar esto, puedes pasar `isEncrypted` en su lugar**:

**App.jsx**
```jsx
import { useState } from 'react';
import ChatRoom from './ChatRoom.js';

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isEncrypted, setIsEncrypted] = useState(false);
  return (
    <>
      <label>
        Selecciona la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isEncrypted}
          onChange={e => setIsEncrypted(e.target.checked)}
        />
        Activar encriptaci√≥n
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        isEncrypted={isEncrypted} // üëà
      />
    </>
  );
}
```

**ChatRoom.jsx**
```jsx
import { useState, useEffect } from 'react';
import {
  createEncryptedConnection,
  createUnencryptedConnection,
} from './chat.js';

export default function ChatRoom({ roomId, isEncrypted }) { // üëà
  useEffect(() => {
    const createConnection = isEncrypted ? // üëà
      createEncryptedConnection :
      createUnencryptedConnection;
    const connection = createConnection(roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, isEncrypted]);// üëà

  return <h1>¬°Bienvenido a la sala {roomId}!</h1>;
}
```

En esta versi√≥n, el componente `App` pasa una prop booleana en lugar de una funci√≥n. Dentro del Efecto, decides qu√© funci√≥n usar. Dado que tanto `createEncryptedConnection` como `createUnencryptedConnection` se declaran fuera del componente, no son reactivos y no necesitan ser dependencias. Aprender√°s m√°s sobre esto en [Eliminar dependencias de los Efectos.](https://es.react.dev/learn/removing-effect-dependencies)

## Desaf√≠o¬†5¬†de¬†5: Rellenar una cadena de cuadros de selecci√≥n¬†

En este ejemplo, hay dos cuadros de selecci√≥n. Un cuadro de selecci√≥n permite al usuario elegir un planeta. Otro cuadro de selecci√≥n permite al usuario elegir un lugar _en ese planeta_. El segundo cuadro no funciona todav√≠a. Tu tarea es hacer que muestre los lugares en el planeta elegido.

Mira c√≥mo funciona el primer cuadro de selecci√≥n. Rellena la variable de estado `planetList` con el resultado de la llamada a la API `"/planets"`. El ID del planeta actualmente seleccionado se mantiene en la variable de estado `planetId`. Necesitas encontrar d√≥nde agregar alg√∫n c√≥digo adicional para que la variable de estado `placeList` se rellene con el resultado de la llamada a la API `"/planets/" + planetId + "/places"`.

Si lo haces bien, seleccionar un planeta deber√≠a rellenar la lista de lugares. Cambiar un planeta deber√≠a cambiar la lista de lugares.

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { fetchData } from './api.js';

export default function Page() {
  const [planetList, setPlanetList] = useState([])
  const [planetId, setPlanetId] = useState('');

  const [placeList, setPlaceList] = useState([]);
  const [placeId, setPlaceId] = useState('');

  useEffect(() => {
    let ignore = false;
    fetchData('/planets').then(result => {
      if (!ignore) {
        console.log('Se obtuvo una lista de planetas.');
        setPlanetList(result);
        setPlanetId(result[0].id); // Se selecciona el primer planeta
      }
    });
    return () => {
      ignore = true;
    }
  }, []);

  return (
    <>
      <label>
        Elige un planeta:{' '}
        <select value={planetId} onChange={e => {
          setPlanetId(e.target.value);
        }}>
          {planetList.map(planet =>
            <option key={planet.id} value={planet.id}>{planet.name}</option>
          )}
        </select>
      </label>
      <label>
        Elige un lugar:{' '}
        <select value={placeId} onChange={e => {
          setPlaceId(e.target.value);
        }}>
          {placeList.map(place =>
            <option key={place.id} value={place.id}>{place.name}</option>
          )}
        </select>
      </label>
      <hr />
      <p>Est√°s yendo a: {placeId || '???'} en {planetId || '???'} </p>
    </>
  );
}
```

### Respuesta

Hay dos procesos de sincronizaci√≥n independientes:

- La primera caja de selecci√≥n est√° sincronizada con la lista remota de planetas.
- La segunda caja de selecci√≥n est√° sincronizada con la lista remota de lugares para el¬†`planetId`¬†actual.

Por eso tiene sentido describirlos como dos Efectos separados. Aqu√≠ tienes un ejemplo de c√≥mo podr√≠as hacerlo:

**App.jsx**
```jsx
import { useState, useEffect } from 'react';
import { fetchData } from './api.js';

export default function Page() {
  const [planetList, setPlanetList] = useState([])
  const [planetId, setPlanetId] = useState('');

  const [placeList, setPlaceList] = useState([]);
  const [placeId, setPlaceId] = useState('');

  useEffect(() => {
    let ignore = false;
    fetchData('/planets').then(result => {
      if (!ignore) {
        console.log('Se obtuvo una lista de planetas.');
        setPlanetList(result);
        setPlanetId(result[0].id); // Se selecciona el primer planeta
      }
    });
    return () => {
      ignore = true;
    }
  }, []);

  useEffect(() => { // üëà
    let ignore = false;
    if (!planetId) return () => ignore = true;

    fetchData(`/planets/${planetId}/places`).then(result => {
      if (!ignore) {
        console.log('Se obtuvo una lista de lugares.');
        setPlaceList(result);
        setPlaceId(result[0].id); // Selecciona el primer lugar
      }
    });
    return () => {
      ignore = true;
    }
  }, [planetId])// üëà

  return (
    <>
      <label>
        Elige un planeta:{' '}
        <select value={planetId} onChange={e => {
          setPlanetId(e.target.value);
        }}>
          {planetList.map(planet =>
            <option key={planet.id} value={planet.id}>{planet.name}</option>
          )}
        </select>
      </label>
      <label>
        Elige un lugar:{' '}
        <select value={placeId} onChange={e => {
          setPlaceId(e.target.value);
        }}>
          {placeList.map(place =>
            <option key={place.id} value={place.id}>{place.name}</option>
          )}
        </select>
      </label>
      <hr />
      <p>Est√°s yendo a: {placeId || '???'} en {planetId || '???'} </p>
    </>
  );
}
```

Este c√≥digo es un poco repetitivo. Sin embargo, ¬°no es una buena raz√≥n para combinarlo en un solo Efecto! Si hicieras esto, tendr√≠as que combinar las dependencias de ambos Efectos en una sola lista, y luego cambiar el planeta volver√≠a a buscar la lista de todos los planetas. Los Efectos no son una herramienta para reutilizar c√≥digo.

**==En su lugar, para reducir la repetici√≥n, puede extraer algo de l√≥gica en un Hook de React personalizado como `useSelectOptions` a continuaci√≥n==**:

**App.jsx**
```jsx
import { useState } from 'react';
import { useSelectOptions } from './useSelectOptions.js'; // üëà

export default function Page() {
  const [
    planetList,
    planetId,
    setPlanetId
  ] = useSelectOptions('/planets'); // üëà

  const [
    placeList,
    placeId,
    setPlaceId
  ] = useSelectOptions(planetId ? `/planets/${planetId}/places` : null); // üëà

  return (
    <>
      <label>
        Escoge un planeta:{' '}
        <select value={planetId} onChange={e => {
          setPlanetId(e.target.value);
        }}>
          {planetList?.map(planet =>
            <option key={planet.id} value={planet.id}>{planet.name}</option>
          )}
        </select>
      </label>
      <label>
        Escoge un lugar:{' '}
        <select value={placeId} onChange={e => {
          setPlaceId(e.target.value);
        }}>
          {placeList?.map(place =>
            <option key={place.id} value={place.id}>{place.name}</option>
          )}
        </select>
      </label>
      <hr />
      <p>Est√°s yendo a: {placeId || '...'} en {planetId || '...'} </p>
    </>
  );
}
```

**useSelectOptions.js**
```jsx
import { useState, useEffect } from 'react';
import { fetchData } from './api.js';

export function useSelectOptions(url) { // üëà
  const [list, setList] = useState(null);
  const [selectedId, setSelectedId] = useState('');
  useEffect(() => {
    if (url === null) {
      return;
    }

    let ignore = false;
    fetchData(url).then(result => {
      if (!ignore) {
        setList(result);
        setSelectedId(result[0].id);
      }
    });
    return () => {
      ignore = true;
    }
  }, [url]);
  return [list, selectedId, setSelectedId];
}
```

Verifica la pesta√±a `useSelectOptions.js` en el sandbox para ver c√≥mo funciona. Idealmente, la mayor√≠a de los Efectos en tu aplicaci√≥n eventualmente deber√≠an reemplazarse por Hooks personalizados, ya sea escritos por ti o por la comunidad. Los Hooks personalizados ocultan la l√≥gica de sincronizaci√≥n, por lo que el componente de llamada no sabe sobre el Efecto. A medida que sigas trabajando en tu aplicaci√≥n, desarrollar√°s una paleta de Hooks para elegir, y eventualmente no necesitar√°s escribir Efectos en tus componentes con mucha frecuencia.