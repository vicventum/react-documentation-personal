## Desaf칤o1맋e4:Reproduce y pausa el video

En este ejemplo, el bot칩n alterna una variable de estado para cambiar entre un estado de reproducci칩n y un estado de pausa. Sin embargo, para que reproduzca o pause el video, alternar el estado no es suficiente. Tambi칠n necesitas llamar a [`play()`](https://developer.mozilla.org/es/docs/Web/API/HTMLMediaElement/play) y [`pause()`](https://developer.mozilla.org/es/docs/Web/API/HTMLMediaElement/pause) en el elemento DOM para el `<video>`. Agrega una ref en 칠l, y haz que el bot칩n funcione.

**App.jsx**
```jsx
import { useState, useRef } from 'react';

export default function VideoPlayer() {
  const [isPlaying, setIsPlaying] = useState(false);

  function handleClick() {
    const nextIsPlaying = !isPlaying;
    setIsPlaying(nextIsPlaying);
  }

  return (
    <>
      <button onClick={handleClick}>
        {isPlaying ? 'Pausar' : 'Reproducir'}
      </button>
      <video width="250">
        <source
          src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
          type="video/mp4"
        />
      </video>
    </>
  )
}
```

Muestra: 

![[2.1-manipular-el-dom-con-refs-1.png]]

Al hacer click en el bot칩n el texto de este cambia, pero el video no se reproduce:

![[2.1-manipular-el-dom-con-refs-2.png]]

Para un desaf칤o extra, mant칠n el bot칩n 춺Reproducir췉 sincronizado con la reproducci칩n del v칤deo, incluso si el usuario hace clic con el bot칩n derecho del rat칩n en el v칤deo y lo reproduce utilizando los controles multimedia integrados en el navegador. Para ello, es posible que quieras escuchar `onPlay` y `onPause` en el v칤deo.

### Respuesta

Declara una ref y col칩cala en el elemento `<video>`. Luego llama a `ref.current.play()` y `ref.current.pause()` en el controlador de evento dependiendo del siguiente estado.

Para manejar los controles integrados del navegador, puedes agregar los controladores `onPlay` y `onPause` al elemento `<video>` y llamar a `setIsPlaying` desde ellos. De esta manera, si el usuario reproduce el video usando los controles del navegador, el estado se ajustar치 en consecuencia.

**App.jsx**
```jsx
import { useState, useRef } from 'react';

export default function VideoPlayer() {
  const [isPlaying, setIsPlaying] = useState(false);
  const videoRef = useRef(null) // 游녣

  function handleClick() {
    const nextIsPlaying = !isPlaying;
    setIsPlaying(nextIsPlaying);
    if (nextIsPlaying) videoRef.current.play() // 游녣
    else videoRef.current.pause() // 游녣
  }

  function handleOnPlay() { // 游녣
    setIsPlaying(true)
  }
  function handleOnPause() { // 游녣
    setIsPlaying(false)
  }

  return (
    <>
      <button onClick={handleClick}>
        {isPlaying ? 'Pausar' : 'Reproducir'}
      </button>
      <video ref={videoRef} width="250" onPlay={handleOnPlay} onPause={handleOnPause}> // 游녣
        <source
          src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
          type="video/mp4"
        />
      </video>
    </>
  )
}
```

Ahora el video se reproduce, y el texto del bot칩n cambia correctamente incluso cuando activamos los controles nativos del video:

![[2.1-manipular-el-dom-con-refs-3.png]]

## Desaf칤o2맋e4: Enfoca el campo de b칰squeda

Haz que al hacer click en el bot칩n 춺Buscar췉 se enfoque en el campo de texto _input_.

**App.jsx**
```jsx
export default function Page() {
  return (
    <>
      <nav>
        <button>Buscar</button>
      </nav>
      <input
        placeholder="쮹uscando algo?"
      />
    </>
  );
}
```

Muestra:

![[2.1-manipular-el-dom-con-refs-4.png]]

Al pulsar sobre el bot칩n, el input no se enfoca:

![[2.1-manipular-el-dom-con-refs-4.png]]

### Soluci칩n

Agrega una ref al _input_, y llama a `focus()` en el nodo DOM para enfocarlo:

**App.jsx**
```jsx
import { useRef } from 'react' // 游녣

export default function Page() {
  const inputRef = useRef(null) // 游녣
  
  function handleClick() { // 游녣
    inputRef.current.focus() // 游녣
  }

  return (
    <>
      <nav>
        <button onClick={handleClick}>Buscar</button> // 游녣
      </nav>
      <input
        ref={inputRef} // 游녣
        placeholder="쮹uscando algo?"
      />
    </>
  );
}
```

Ahora al presionar sobre el bot칩n el input se enfoca:

![[2.1-manipular-el-dom-con-refs-5.png]]


## Desaf칤o3맋e4:Desplazar un carrusel de im치genes

Este carrusel de im치genes tiene un bot칩n 춺Siguiente췉 que cambia la imagen activa. Haz que la galer칤a se desplace horizontalmente hasta la imagen activa al hacer clic. Tu querr치s llamar a [`scrollIntoView()`](https://developer.mozilla.org/es/docs/Web/API/Element/scrollIntoView) en el nodo DOM de la imagen activa:

```jsx
node.scrollIntoView({
  behavior: 'smooth',
  block: 'nearest',
  inline: 'center'
});
```

**App.jsx**
```jsx
import { useState } from 'react';

export default function CatFriends() {
  const [index, setIndex] = useState(0);
  return (
    <>
      <nav>
        <button onClick={() => {
          if (index < catList.length - 1) {
            setIndex(index + 1);
          } else {
            setIndex(0);
          }
        }}>
          Siguiente
        </button>
      </nav>
      <div>
        <ul>
          {catList.map((cat, i) => (
            <li key={cat.id}>
              <img
                className={
                  index === i ?
                    'active' :
                    ''
                }
                src={cat.imageUrl}
                alt={'Cat #' + cat.id}
              />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: 'https://placekitten.com/250/200?image=' + i
  });
}
```

Muestra:

![[2.1-manipular-el-dom-con-refs-8.png|660]]

Si se pulsa el bot칩n "Siguiente", el borde de la imagen se traslada a la imagen siguiente, pero dicha imagen no se centra en la pantalla:

![[2.1-manipular-el-dom-con-refs-9.png]]

### Respuesta

Puedes declarar una `selectedRef`, y pasarla condicionalmente solo a la imagen actual:

```jsx
<li ref={index === i ? selectedRef : null}>
```

Cuando `index === i`, significa que esa imagen es la seleccionada, el `<li>` recibir치 la `selectedRef`. React se asegurar치 de que `selectedRef.current` siempre apunta al nodo DOM correcto.

Ten en cuenta que la llamada `flushSync` es necesaria para forzar a React a actualizar el DOM antes del desplazamiento. De lo contrario, `selectedRef.current` siempre apuntar치 al elemento anteriormente seleccionado.


```jsx
import { useRef, useState } from 'react'; // 游녣
import { flushSync } from 'react-dom';

export default function CatFriends() {
  const selectedRef = useRef(null); // 游녣
  const [index, setIndex] = useState(0);

  return (
    <>
      <nav>
        <button onClick={() => {
          flushSync(() => { // 游녣
            if (index < catList.length - 1) {
              setIndex(index + 1);
            } else {
              setIndex(0);
            }
          });
          selectedRef.current.scrollIntoView({ // 游녣
            behavior: 'smooth',
            block: 'nearest',
            inline: 'center'
          });            
        }}>
          Siguiente
        </button>
      </nav>
      <div>
        <ul>
          {catList.map((cat, i) => (
            <li
              key={cat.id}
              ref={index === i ? // 游녣
                selectedRef :
                null
              }
            >
              <img
                className={
                  index === i ?
                    'active'
                    : ''
                }
                src={cat.imageUrl}
                alt={'Cat #' + cat.id}
                width="300"
                height="300"
                style={{'object-fit': 'cover'}}
              />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: `https://randomfox.ca/images/${i+1}.jpg`
  });
}

```

Ahora la imagen s칤 se centra al pulsar el bot칩n:

![[2.1-manipular-el-dom-con-refs-10.png]]

## Desaf칤o4맋e4:Enfoca el campo de b칰squeda con componentes separados

Haz que al hacer clic en el bot칩n 춺Buscar췉 se ponga el foco en el campo de texto _input_. Ten en cuenta que cada componente se define en un archivo separado y no debe moverse fuera de 칠l. 쮺omo los conectar칤as entre ellos?.

**App.jsx**
```jsx
import SearchButton from './SearchButton.js';
import SearchInput from './SearchInput.js';

export default function Page() {
  return (
    <>
      <nav>
        <SearchButton />
      </nav>
      <SearchInput />
    </>
  );
}
```

**SearchButton.jsx**
```jsx
export default function SearchButton() {
  return (
    <button>
      Buscar
    </button>
  );
}
```

**SearchInput.jsx**
```jsx
export default function SearchInput() {
  return (
    <input
      placeholder="쮹uscando algo?"
    />
  );
}
```

Muestra:

![[2.1-manipular-el-dom-con-refs-6.png]]

Si pulsamos sobre el bot칩n no se enfoca el input:

![[2.1-manipular-el-dom-con-refs-6.png]]

### Respuesta

Necesitar치s agregar una propiedad `onClick` a `SearchButton`, y hacer que `SearchButton` lo pase al `<button>` del navegador. Tambi칠n pasar치s una ref a `<SearchInput>`, que lo va a redirigir al `<input>` real y la completar치. Finalmente, en el controlador de clic, llamar치s a `focus` en el nodo DOM almacenado dentro de esa ref.

**App.jsx**
```jsx
import { useRef } from 'react' // 游녣
import SearchButton from './SearchButton.js';
import SearchInput from './SearchInput.js';

export default function Page() {
  const inputRef = useRef(null) // 游녣

  function handleClick() { // 游녣
    inputRef.current.focus() // 游녣
  }

  return (
    <>
      <nav>
        <SearchButton onClick={handleClick} /> // 游녣
      </nav>
      <SearchInput ref={inputRef} /> // 游녣
    </>
  );
}
```

**SearchButton.jsx**
```jsx
export default function SearchButton({onClick}) { // 游녣
  return (
    <button onClick={onClick}> // 游녣
      Buscar
    </button>
  );
}
```

**SearchInput.jsx**
```jsx
import { forwardRef } from 'react' // 游녣

export default SearchInput = forwardRef((props, ref) => {
  return (
    <input
      ref={ref} // 游녣
      placeholder="쮹uscando algo?"
    />
  );
})
```

Muestra:

![[2.1-manipular-el-dom-con-refs-6.png]]

Si pulsamos sobre el bot칩n ahora el input se enfoca correctamente:

![[2.1-manipular-el-dom-con-refs-7.png]]