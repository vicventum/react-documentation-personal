Los controladores de eventos solo se vuelven a ejecutar cuando vuelves a realizar la misma interacci√≥n. A diferencia de los controladores de eventos, los Efectos se resincronizan si alg√∫n valor que leen, como una prop o una variable de estado, es diferente de lo que era durante el √∫ltimo renderizado. **A veces, tambi√©n quieres una mezcla de ambos comportamientos: un Efecto que se vuelve a ejecutar en respuesta a algunos valores pero no a otros. Esta p√°gina te ense√±ar√° c√≥mo hacerlo**.

### Aprender√°s

- C√≥mo escoger entre un controlador de evento y un Efecto
- Por qu√© los Efectos son reactivos, y los controladores de eventos no lo son
- Qu√© hacer cuando quieres que una parte del c√≥digo de tu Efecto no sea reactivo
- Qu√© son los eventos de Efecto y c√≥mo extraerlos de tus Efectos
- C√≥mo leer las √∫ltimas props y estados de los Efectos usando Eventos de Efecto

## Elegir entre controladores de eventos y Efectos¬†

Primero, vamos a recapitular la diferencia entre controladores de eventos y Efectos.

Imagina que estas implementando un componente de sala de chat. Tus requerimientos se ver√°n as√≠:

1. Tu componente deber√≠a conectarse de forma autom√°tica a la sala de chat seleccionada.
2. Cu√°ndo hagas click al bot√≥n ¬´Enviar¬ª, deber√≠a enviar un mensaje al chat.

Digamos que ya tienes el c√≥digo implementado para ello, pero no estas seguro de donde ponerlo. ¬øDeber√≠as de usar controladores de eventos o Efectos? Cada vez que necesites contestar este pregunta, considera [_por qu√©_ se necesita ejecutar el c√≥digo.](https://es.react.dev/learn/synchronizing-with-effects#what-are-effects-and-how-are-they-different-from-events)

### ‚≠ê Los controladores de eventos se ejecutan en respuesta a interacciones especificas

**Desde la perspectiva del usuario, el env√≠o de un mensaje debe producirse _porque_ se hace clic en particular en el bot√≥n ¬´Enviar¬ª**. El usuario se enfadar√° bastante si env√≠as su mensaje en cualquier otro momento o por cualquier otro motivo. Esta es la raz√≥n por la que enviar un mensaje deber√≠a ser un controlador de evento. Los controladores de eventos te permiten controlar interacciones espec√≠ficas:

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() { // üëà
    sendMessage(message); // üëà
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Enviar</button>
    </>
  );
}
```

**Con un controlador de Evento, puedes estar seguro que `sendMessage(message)` _√∫nicamente_ se activar√° si el usuario presiona el bot√≥n**.

### ‚≠ê Los Efectos se ejecutan siempre que es necesaria la sincronizaci√≥n¬†

Recuerda que tambi√©n necesitas mantener el componente conectado a la sala de chat. ¬øD√≥nde va ese c√≥digo?

**La _raz√≥n_ para ejecutar este c√≥digo no es ninguna interacci√≥n en particular**. No es importante, el c√≥mo o de qu√© forma el usuario naveg√≥ hasta la sala de chat. Ahora que ellos est√°n vi√©ndola y pueden interactuar con ella, el componente necesita mantenerse conectado al servidor de chat seleccionado. **Incluso si el componente de la sala de chat fuera la pantalla inicial de tu aplicaci√≥n y el usuario no ha realizado ning√∫n tipo de interacci√≥n, _todav√≠a_ necesitar√≠as conectarte. Es por eso que es un Efecto**:

```jsx
function ChatRoom({ roomId }) {
  // ...
  useEffect(() => { // üëà
    const connection = createConnection(serverUrl, roomId); // üëà
    connection.connect(); // üëà
    return () => { // üëà
      connection.disconnect(); // üëà
    };
  }, [roomId]); // üëà
  // ...
}
```

Con este c√≥digo, puedes estar seguro que siempre hay una conexi√≥n activa al servidor de chat seleccionado actualmente, _independientemente_ de las interacciones espec√≠ficas realizadas por el usuario. **Si el usuario solo ha abierto tu aplicaci√≥n, seleccionado una sala diferente o navegado a otra pantalla y volvi√≥, tu Efecto garantiza que el componente _permanecer√° sincronizado_ con la sala seleccionada a actualmente, y [volver√° a conectarse cuando sea necesario.](https://es.react.dev/learn/lifecycle-of-reactive-effects#why-synchronization-may-need-to-happen-more-than-once)**

**App.js**
```jsx
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  function handleSendClick() {
    sendMessage(message);
  }

  return (
    <>
      <h1>¬°Bienvenido a la sala {roomId}!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Enviar</button>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Selecciona la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Cerrar chat' : 'Abrir chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

**chat.js**
```jsx
export function sendMessage(message) {
  console.log('üîµ Enviaste: ' + message);
}

export function createConnection(serverUrl, roomId) {
  // Una aplicaci√≥n real se conectar√≠a al servidor
  return {
    connect() {
      console.log('‚úÖ Conectando a la sala "' + roomId + '" en ' + serverUrl + '...');
    },
    disconnect() {
      console.log('‚ùå Desconectando de la sala "' + roomId + '" en ' + serverUrl);
    }
  };
}
```

Muestra:

![[5-ciclo-de-vida-de-los-efectos-reactivos-1.png]]

Al presionar sobre el bot√≥n, el componente del chat se montar√° y se mostrar√°n 3 mensajes en la consola:

![[6-separar-eventos-de-efectos-1.png]]

## üåü Valores reactivos y l√≥gica reactiva¬†

**Intuitivamente, podr√≠a decirse que los controladores de eventos siempre se activan ¬´manualmente¬ª, por ejemplo, al pulsar un bot√≥n. Los Efectos, en cambio, son ¬´autom√°ticos¬ª: se ejecutan y se vuelven a ejecutar tantas veces como sea necesario para mantenerse sincronizados**.

**Hay una forma m√°s precisa de pensar en esto**.

Las propiedades, estados, y variables declarados dentro del cuerpo de tu componente son llamados valores reactivos. En este ejemplo, `serverUrl` no es un valor reactivo, pero `roomId` y `message` s√≠ lo son. Participan en el flujo de datos de renderizado:

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // ...
}
```

**Valores reactivos como estos pueden cambiar debido a un re-renderizado**. Por ejemplo, el usuario puede editar el `message` o elegir un `roomId` diferente en un desplegable. **Los controladores de eventos y Efectos responden a los cambios de manera diferente**:

- **La l√≥gica dentro de los controladores de eventos no es¬†_reactiva._**¬†**No se ejecutar√° de nuevo a menos que el usuario vuelva a realizar la misma interacci√≥n (por ejemplo, un clic)**. Los controladores de eventos pueden leer valores reactivos sin ¬´reaccionar¬ª a sus cambios.
- **La l√≥gica dentro de los Efectos es¬†_reactiva._**¬†**Si tu Efecto lee un valor reactivo,¬†[tienes que especificarlo como una dependencia](https://es.react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values)**¬†Luego, si una nueva renderizaci√≥n hace que ese valor cambie, React volver√° a ejecutar la l√≥gica de tu Efecto con el nuevo valor.

Volvamos al ejemplo anterior para ilustrar esta diferencia.

### La l√≥gica dentro de los controladores de eventos no es reactiva

Echa un vistazo a esta l√≠nea de c√≥digo. ¬øEsta l√≥gica deber√≠a ser reactiva o no?

```jsx
    // ...
    sendMessage(message);
    // ...
```

Desde la perspectiva del usuario, **un cambio en el `message` _no_ significa que quiera enviar un mensaje.** Solo significa que el usuario est√° escribiendo. En otras palabras, **la l√≥gica que env√≠a un mensaje no deber√≠a ser reactiva. No deber√≠a volver a ejecutarse solo porque el valor reactivo ha cambiado. Por eso pertenece al controlador de evento**:

```jsx
  function handleSendClick() {
    sendMessage(message);
  }
```

Los controladores de eventos no son reactivos, por lo que `sendMessage(message)` solo se ejecutar√° cuando el usuario pulse el bot√≥n Enviar.

### La l√≥gica dentro de los Efectos es reactiva

Ahora volvamos a estas l√≠neas:

```jsx
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    // ...
```

Desde la perspectiva del usuario, **un cambio en el `roomId` _significa_ que quieren conectarse a una sala diferente.** En otras palabras, **la l√≥gica para conectarse a la sala debe ser reactiva**. Usted _quiere_ estas l√≠neas de c√≥digo para ¬´mantenerse al d√≠a¬ª con el valor reactivo, y para ejecutar de nuevo si ese valor es diferente. **Es por eso que pertenece en un Efecto**:

```jsx
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // üëà
    connection.connect(); // üëà
    return () => {
      connection.disconnect()
    };
  }, [roomId]);
```

Los Efectos son reactivos, por lo que `createConnection(serverUrl, roomId)` y `connection.connect()` se ejecutar√°n para cada valor distinto de `roomId`. Tu Efecto mantiene la conexi√≥n de chat sincronizada con la sala seleccionada en ese momento.

## ‚≠ê Extraer l√≥gica no reactiva fuera de los Efectos

**Las cosas se vuelven m√°s complicadas cuando tu quieres combinar l√≥gica reactiva con l√≥gica no reactiva**.

Por ejemplo, imagina que quieres mostrar una notificaci√≥n cuando el usuario se conecta al chat. Lees el tema actual (oscuro o claro) de los accesorios para poder mostrar la notificaci√≥n en el color correcto:

```jsx
function ChatRoom({ roomId, theme }) { // üëà
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => { // üëà
      showNotification('¬°Conectado!', theme); // üëà
    });
    connection.connect();
    // ...
```

Sin embargo, `theme` es un valor reactivo (puede cambiar como resultado del re-renderizado), y [cada valor reactivo le√≠do por un Efecto debe ser declarado como su dependencia](https://es.react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) Ahora tienes que especificar `theme` como una dependencia de tu Efecto:

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('¬°Conectado!', theme); // üëà
    });
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId, theme]); // ‚úÖ Todas las dependencias declaradas üëà
  // ...
```

Juegue con este ejemplo y vea si puede detectar el problema con esta experiencia de usuario:

**App.js**
```jsx
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('¬°Conectado!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);

  return <h1>¬°Bienvenido a la sala {roomId}!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Escoje la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Usar tema oscuro
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

**chat.js**
```jsx
export function createConnection(serverUrl, roomId) {
  // Una aplicaci√≥n real se conectar√≠a al servidor
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('No se puede agregar el controlador dos veces.');
      }
      if (event !== 'connected') {
        throw Error('Solo se admite el evento "connected".');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

**notifications.js**
```jsx
import Toastify from 'toastify-js';
import 'toastify-js/src/toastify.css';

export function showNotification(message, theme) {
  Toastify({
    text: message,
    duration: 2000,
    gravity: 'top',
    position: 'right',
    style: {
      background: theme === 'dark' ? 'black' : 'white',
      color: theme === 'dark' ? 'white' : 'black',
    },
  }).showToast();
}
```

Muestra la notificaci√≥n a penas se monta el componente o cuando se cambia de chat:

![[6-separar-eventos-de-efectos-2.png]]

Pero cuando cambiamos de tema tambi√©n se muestra la notificaci√≥n (cosa que no deber√≠a):

![[6-separar-eventos-de-efectos-3.png]]

**Cuando el `roomId` cambia, el chat se reconecta como es de esperar. Pero como `theme` tambi√©n es una dependencia, el chat _tambi√©n_ se reconecta cada vez que cambias entre el tema oscuro y el claro. Esto no es bueno**.

En otras palabras, _**no_ quieres que esta l√≠nea sea reactiva, aunque est√© dentro de un Efecto (que es reactivo)**:

```jsx
      // ...
      showNotification('¬°Conectado!', theme);
      // ...
```

Necesitas una forma de separar esta l√≥gica no reactiva del Efecto reactivo que la rodea.

### üåü `useEffectEvent` - Declaraci√≥n de un Evento de Efecto

> [!danger]
> #### En construcci√≥n
> Esta secci√≥n describe una API **experimental que a√∫n no se ha publicado** en una versi√≥n estable de React.

Utiliza un Hook especial llamado [`useEffectEvent`](https://es.react.dev/reference/react/experimental_useEffectEvent) para extraer esta l√≥gica no reactiva de su Efecto:

```jsx
import { useEffect, useEffectEvent } from 'react'; // üëà

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => { // üëà
    showNotification('¬°Conectado!', theme); // üëà
  });
  // ...
```

**Aqu√≠, `onConnected` se llama un _Evento de Efecto._ Es una parte de tu l√≥gica de Efecto, pero se comporta mucho m√°s como un controlador de evento**. La l√≥gica dentro de √©l no es reactiva, y siempre ¬´ve¬ª los √∫ltimos valores de tus props y estado.

**Ahora puedes llamar al Evento de Efecto `onConnected` desde dentro de tu Efecto**:

```jsx
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => { // üëà
    showNotification('¬°Conectado!', theme); // üëà
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected(); // üëà
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ Todas las dependencias declaradas üëà
  // ...
```

**Esto resuelve el problema**. Ten en cuenta que has tenido que _eliminar_ `onConnected` de la lista de dependencias de tu Efecto. **Los Eventos de Efecto no son reactivos y deben ser omitidos de las dependencias.** Verifica que el nuevo comportamiento funciona como esperas:

**App.js**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => { // üëà
    showNotification('¬°Conectado!', theme); // üëà
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected(); // üëà
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ Todas las dependencias declaradas üëà

  return <h1>¬°Bienvenido a la sala {roomId}!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Escoje la sala de chat:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="viaje">viaje</option>
          <option value="m√∫sica">m√∫sica</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Usar tema oscuro
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

**chat.js**
```jsx
export function createConnection(serverUrl, roomId) {
  // Una aplicaci√≥n real se conectar√≠a al servidor
  let connectedCallback;
  let timeout;
  return {
    connect() {
      timeout = setTimeout(() => {
        if (connectedCallback) {
          connectedCallback();
        }
      }, 100);
    },
    on(event, callback) {
      if (connectedCallback) {
        throw Error('No se puede a√±adir el controlador dos veces.');
      }
      if (event !== 'connected') {
        throw Error('Solo se admite el evento "connected".');
      }
      connectedCallback = callback;
    },
    disconnect() {
      clearTimeout(timeout);
    }
  };
}
```

Muestra la notificaci√≥n a penas se monta el componente o cuando se cambia de chat:

![[6-separar-eventos-de-efectos-2.png]]

Pero ahora cuando cambiamos de tema, ya no se dispara la notificaci√≥n:

![[6-separar-eventos-de-efectos-4.png]]

**Puedes pensar que los Eventos de Efecto son muy similares a los controladores de eventos. La principal diferencia es que los controladores de eventos se ejecutan en respuesta a las interacciones del usuario, mientras que los Eventos de Efecto son disparados por ti desde los Efectos**. Los Eventos de Efecto te permiten ¬´romper la cadena¬ª entre la reactividad de los Efectos y el c√≥digo que no deber√≠a ser reactivo.

### ‚≠ê Leer las √∫ltimas propiedades y el estado con los Eventos de Efecto

> [!danger]
> #### En construcci√≥n
> Esta secci√≥n describe una API **experimental que a√∫n no se ha publicado** en una versi√≥n estable de React.

**Los Eventos de Efecto le permiten arreglar muchos patrones en los que podr√≠a verse tentado a eliminar el linter de dependencias**.

Por ejemplo, digamos que tienes un Efecto para registrar las visitas a la p√°gina:

```jsx
function Page() {
  useEffect(() => {
    logVisit();
  }, []);
  // ...
}
```

M√°s tarde, a√±ades m√∫ltiples rutas a tu sitio. Ahora tu componente `Page` recibe una propiedad `url` con la ruta actual. Quieres pasar la `url` como parte de tu llamada `logVisit`, pero el linter de dependencias se queja:

```jsx
function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, []); // üî¥ Hook de React useEffect tiene una dependencia que falta: 'url' ‚ùå
  // ...
}
```

**Piense en lo que quiere que haga el c√≥digo**. Usted _quiere_ registrar una visita separada para diferentes URLs ya que cada URL representa una p√°gina diferente. En otras palabras, **esta llamada a `logVisit` _deber√≠a_ ser reactiva con respecto a la `url`. Por eso, en este caso, tiene sentido seguir el linter de dependencias, y a√±adir `url` como dependencia**:

```jsx
function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, [url]); // ‚úÖ Todas las dependencias declaradas
  // ...
}
```

Supongamos ahora que desea incluir el n√∫mero de art√≠culos en el carrito de compras junto con cada visita a la p√°gina:

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext); // üëà
  const numberOfItems = items.length; // üëà

  useEffect(() => {
    logVisit(url, numberOfItems); // üëà
  }, [url]); // üî¥ React Hook useEffect has a missing dependency: 'numberOfItems'
  // ...
}
```

**Has utilizado `numberOfItems` dentro del Efecto, por lo que el linter te pide que lo a√±adas como dependencia. Sin embargo, _no_ quieres que la llamada a `logVisit` sea reactiva con respecto a `numberOfItems`**. Si el usuario pone algo en el carro de la compra, y el `numberOfItems` cambia, esto _no significa_ que el usuario haya visitado la p√°gina de nuevo. En otras palabras, _**visitar la p√°gina_ es, en cierto sentido, un ¬´evento¬ª. Ocurre en un momento preciso**.

**Divide el c√≥digo en dos partes**:

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onVisit = useEffectEvent(visitedUrl => { // üëà
    logVisit(visitedUrl, numberOfItems); // üëà
  });

  useEffect(() => {
    onVisit(url); // üëà
  }, [url]); // ‚úÖ Todas las dependencias declaradas
  // ...
}
```

**Aqu√≠, `onVisit` es un Evento de Efecto. El c√≥digo que contiene no es reactivo. Por eso puedes usar `numberOfItems` (¬°o cualquier otro valor reactivo!) sin preocuparte de que cause que el c√≥digo circundante se vuelva a ejecutar con los cambios**.

**Por otro lado, el Efecto en s√≠ sigue siendo reactivo**. El c√≥digo dentro del Efecto utiliza la propiedad `url`, por lo que el Efecto se volver√° a ejecutar despu√©s de cada rerenderizado con una `url` diferente. Esto, a su vez, llamar√° al Evento de Efecto ¬´`onVisit`¬ª.

Como resultado, se llamar√° a `logVisit` por cada cambio en la `url`, y siempre se leer√° el √∫ltimo `numberOfItems`. Sin embargo, si `numberOfItems` cambia por s√≠ mismo, esto no har√° que se vuelva a ejecutar el c√≥digo.

> [!info]
Puede que te preguntes si podr√≠as llamar a `onVisit()` sin argumentos, y leer la `url` que contiene:
>
>```jsx
  >const onVisit = useEffectEvent(() => {
    >logVisit(url, numberOfItems); // üëà
  >});
>
  >useEffect(() => {
    >onVisit(); // üëà
  >}, [url]);
>```
>
Esto funcionar√≠a, pero es mejor pasar esta `url` al Evento de Efecto expl√≠citamente. **Al pasar `url` como argumento a tu Evento de Efecto, est√°s diciendo que visitar una p√°gina con una `url` diferente constituye un ¬´evento¬ª separado desde la perspectiva del usuario.** La `visitedUrl` es una parte del ¬´evento¬ª que ocurri√≥:
>
>```jsx
  >const onVisit = useEffectEvent(visitedUrl => { // üëà
    >logVisit(visitedUrl, numberOfItems); // üëà
  >});
>
  >useEffect(() => {
    >onVisit(url); // üëà
  >}, [url]);
>```
>
Desde que tu Evento de Efecto ¬´pregunta¬ª expl√≠citamente por la `visitedUrl`, ahora no puedes eliminar accidentalmente `url` de las dependencias del Efecto. Si eliminas la dependencia `url` (provocando que distintas visitas a la p√°gina se cuenten como una), el linter te advertir√° de ello. Quieres que `onVisit` sea reactivo con respecto a la `url`, as√≠ que en lugar de leer la `url` dentro (donde no ser√≠a reactivo), la pasas _desde_ tu Efecto.
>
>Esto es especialmente importante si hay alguna l√≥gica as√≠ncrona dentro del Efecto:
>
>```jsx
  >const onVisit = useEffectEvent(visitedUrl => {
    >logVisit(visitedUrl, numberOfItems);
  >});
>
  >useEffect(() => {
    >setTimeout(() => {
      >onVisit(url);
    >}, 5000); // Retraso en el registro de visitas
  >}, [url]);
>```
>
>Aqu√≠, `url` dentro de `onVisit` corresponde a la _√∫ltima_ `url` (que podr√≠a haber cambiado), pero `visitedUrl` corresponde a la `url` que originalmente caus√≥ que este Efecto (y esta llamada a `onVisit`) se ejecutara.

#### ¬øEst√° bien suprimir el linter de dependencia en su lugar?¬†

En las bases de c√≥digo existentes, a veces puede ver la regla lint suprimida de esta manera:

```jsx
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
    // üî¥ Evite suprimir el linter de este modo: üëà
    // eslint-disable-next-line react-hooks/exhaustive-deps üëà
  }, [url]);
  // ...
}
```

**==Despu√©s de que `useEffectEvent` se convierta en una parte estable de React, recomendamos nunca suprimir el linter==**.

La primera desventaja de suprimir la regla es que React ya no te avisar√° cuando tu Efecto necesite ¬´reaccionar¬ª a una nueva dependencia reactiva que hayas introducido en tu c√≥digo. En el ejemplo anterior, a√±adiste `url` a las dependencias _porque_ React te lo record√≥. Si desactivas el linter, ya no recibir√°s esos recordatorios para futuras ediciones de ese Efecto. Esto conduce a errores.

Aqu√≠ hay un ejemplo de un error confuso causado por la supresi√≥n del linter. En este ejemplo, se supone que la funci√≥n `handleMove` lee el valor actual de la variable de estado `canMove` para decidir si el punto debe seguir al cursor. Sin embargo, `canMove` es siempre `true` dentro de `handleMove`.

¬øPuedes ver por qu√©?

**App.js**
```jsx
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

El punto se mueve en el plano aun cuando se marca la casilla para que no lo haga:

![[6-separar-eventos-de-efectos-5.png|670]]

**El problema con este c√≥digo est√° en suprimir el linter de dependencia. Si eliminas la supresi√≥n, ver√°s que este Efecto deber√≠a depender de la funci√≥n `handleMove`. Esto tiene sentido**: `handleMove` se declara dentro del cuerpo del componente, lo que lo convierte en un valor reactivo. Cada valor reactivo debe ser especificado como una dependencia, ¬°o puede potencialmente volverse obsoleto con el tiempo!

El autor del c√≥digo original ha ¬´mentido¬ª a React diciendo que el Efecto no depende (`[]`) de ning√∫n valor reactivo. Por eso React no ha resincronizado el Efecto despu√©s de que `canMove` haya cambiado (y `handleMove` con √©l). Debido a que React no ha resincronizado el Efecto, el `handleMove` adjunto como listener es la funci√≥n `handleMove` creada durante el render inicial. Durante el render inicial, `canMove` era `true`, por lo que `handleMove` del render inicial ver√° siempre ese valor.

**Si nunca suprimes el linter, nunca ver√°s problemas con valores obsoletos.**

Con `useEffectEvent`, no hay necesidad de ¬´mentir¬ª al linter, y el c√≥digo funciona como cabr√≠a esperar:

**App.js**
```jsx
import { useState, useEffect } from 'react';
import { experimental_useEffectEvent as useEffectEvent } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  const onMove = useEffectEvent(e => {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener('pointermove', onMove);
    return () => window.removeEventListener('pointermove', onMove);
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        El punto puede moverse
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

Ahora s√≠ se activamos en la casilla el punto rojo deja de moverse cuando marcamos la casilla:

![[6-separar-eventos-de-efectos-6.png]]

**Esto no significa que `useEffectEvent` sea _siempre_ la soluci√≥n correcta. Solo deber√≠as aplicarlo a las l√≠neas de c√≥digo que no quieres que sean reactivas**. En el sandbox anterior, no quer√≠as que el c√≥digo del Efecto fuera reactivo con respecto a `canMove`. Por eso ten√≠a sentido extraer un Evento de Efecto.

Leer [Eliminar dependencias de Efectos](https://es.react.dev/learn/removing-effect-dependencies) para otras alternativas correctas a la supresi√≥n del linter.

### Limitaciones de los Eventos de Efecto¬†

> [!danger]
> #### En construcci√≥n
> Esta secci√≥n describe una API **experimental que a√∫n no se ha publicado** en una versi√≥n estable de React.

**==Los Eventos de Efecto tienen un uso muy limitado==**:

- **Ll√°malos solo desde dentro Efectos.**
- **Nunca los pases a otros componentes o Hooks.**

Por ejemplo, no declares y pases un Evento de Efecto as√≠:

```jsx
function Timer() {
  const [count, setCount] = useState(0);

  const onTick = useEffectEvent(() => { // üëà
    setCount(count + 1); // üëà
  });

  useTimer(onTick, 1000); // üî¥ Evitar: Pasar Eventos de Efecto üëà

  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  useEffect(() => {
    const id = setInterval(() => {
      callback();
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay, callback]); // Necesitas especificar "callback" en las dependencias
}
```

En su lugar, declare siempre los Eventos de Efecto directamente junto a los Efectos que los utilizan:

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  useTimer(() => {
    setCount(count + 1);
  }, 1000);
  return <h1>{count}</h1>
}

function useTimer(callback, delay) {
  const onTick = useEffectEvent(() => { // üëà
    callback(); // üëà
  });

  useEffect(() => {
    const id = setInterval(() => {
      onTick(); // ‚úÖ Bien: Solo se activa localmente dentro de un Efecto üëà
    }, delay);
    return () => {
      clearInterval(id);
    };
  }, [delay]); // No es necesario especificar "onTick" (un evento de Efecto) como dependencia. üëà
}
```

Los Eventos de Efecto son ¬´piezas¬ª no reactivas de tu c√≥digo de Efecto. Deben estar junto al Efecto que los utiliza.

## Recapitulaci√≥n

- Los controladores de eventos se ejecutan en respuesta a interacciones espec√≠ficas.
- Los Efectos se ejecutan siempre que es necesaria la sincronizaci√≥n.
- La l√≥gica dentro de los controladores de eventos no es reactiva.
- La l√≥gica dentro de Efectos es reactiva.
- Puede mover la l√≥gica no reactiva de Efectos a Eventos de Efecto.
- Llame a Eventos de Efecto solo desde dentro de Efectos.
- No pase Eventos de Efecto a otros componentes o Hooks.